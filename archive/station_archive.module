<?php

define('STATION_ARCHIVE_CVS_ID', '$Id$');

if (module_exists('views')) {
  require_once(drupal_get_path('module', 'station_archive') .'/views.inc');
  require_once(drupal_get_path('module', 'station_archive') .'/views_defaults.inc');
}

/**
 * Implementation of hook_help().
 */
function station_archive_help($section = '') {
  switch ($section) {
    case 'admin/settings/station/archive':
      return t("These settings let you configure the way the station's webstream is archived into audio nodes. Audio is imported into the archive as part of Drupal's cron task. You'll need to ensure that that is properly configured. ");
    default:
      return NULL;
  }
}

/**
 * Implementation of hook_menu().
 */
function station_archive_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    // legacy menus, views is where it's at now...
    $items[] = array(
      'path' => 'last',
      'title' => t('Show archive'),
      'callback' => 'station_archive_view_html',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'last/hours',
      'callback' => 'station_archive_view_hours_html',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'rss',
      'title' => t('RSS show archive'),
      'callback' => 'station_archive_view_rss',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'rss/hours',
      'callback' => 'station_archive_view_hours_rss',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    // end legacy menu items

    $items[] = array('path' => 'admin/settings/station/archive',
      'title' => t('Archive'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('station_archive_admin_settings'),
      'access' => user_access('administer site configuration'),
      'type' => MENU_LOCAL_TASK
    );
  }

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function station_archive_perm() {
  return array(
    'administer archive',
  );
}

function station_archive_view_html($dayname = NULL, $hourname = NULL) {
  if (!is_null($dayname)) {
    $day = station_valid_day($dayname);
    $vid = _station_archive_get_vid();
    if ($dayterm = _station_archive_get_day_term($vid, $day)) {
      $tid = $dayterm['tid'];

      if (!is_null($hourname)) {
        $hour = station_valid_hour($hourname);
        if ($hourterm = _station_archive_get_hour_term($dayterm, $hour)) {
          $tid = $hourterm['tid'];
        }
      }
      drupal_goto('taxonomy/term/'. $tid);
    }
  }
  drupal_not_found();
}

function station_archive_view_rss($dayname = NULL, $hourname = NULL) {
  if (!is_null($dayname)) {
    $day = station_valid_day($dayname);
    $vid = _station_archive_get_vid();
    if ($dayterm = _station_archive_get_day_term($vid, $day)) {
      $tid = $dayterm['tid'];

      if (!is_null($hourname)) {
        $hour = station_valid_hour($hourname);
        if ($hourterm = _station_archive_get_hour_term($dayterm, $hour)) {
          $tid = $hourterm['tid'];
        }
      }

      drupal_goto('taxonomy/term/'. $tid .'/0/feed');
    }
  }
  drupal_not_found();
}

function station_archive_view_hours_html($hour_string) {
  $title = t('Shows on...');
  $rss_url = url('rss/hours/'. str_replace(' ', '+', $hour_string));

  $attributes = array(
    'rel' => 'alternate',
    'type' => 'application/rss+xml',
    'title' => t('RSS - %title', array('%title' => $title)),
    'href' => $rss_url,
  );
  drupal_add_link($attributes);
  drupal_set_title($title);

  $vid = _station_archive_get_vid();
  $tids = _station_archive_get_hour_tids($vid, $hour_string);
  $result = taxonomy_select_nodes($tids, 'or', 0, FALSE);
  while ($node = db_fetch_object($result)) {
    $output .= node_view(node_load($node), 1);
  }
  $output .= theme('feed_icon', $rss_url);

  return $output;
}

function station_archive_view_hours_rss($hour_string) {
  $title = t('Shows on...');
  $desc = t('Description of shows...');

  $vid = _station_archive_get_vid();
  $tids = _station_archive_get_hour_tids($vid, $hour_string);
  $result = taxonomy_select_nodes($tids, 'or', 'all', FALSE);

  $channel['title'] = $title;
  $channel['description'] = $desc;

  return node_feed($result, $channel);
}

/**
 * Implementation of hook_block().
 */
function station_archive_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
  case 'view':
    if (user_access('access content')) {
      switch($delta) {
        case 1:
          $block['subject'] = t('Browse by day');
          $block['content'] = _station_archive_browse_block();
          break;
      }
      return $block;
    }
    break;

  case 'list':
    $blocks[1]['info'] = t('Station Archive: Browse by taxonomy');
    return $blocks;
  }
}

/**
 * Return HTML for browsing the taxonomy.
 */
function _station_archive_browse_block() {
  $vid = _station_archive_get_vid();
  $tree = taxonomy_get_tree($vid);
  if ($tree) {
    foreach ($tree as $term) {
      if ($term->depth == 0) {
        $items[] = l($term->name, 'taxonomy/term/'. $term->tid);
      }
    }
    return theme('item_list', $items);
  }
}

/**
 * Archive settings form.
 */
function station_archive_admin_settings() {
  $times = array(86400, 172800, 259200, 345600, 432000, 518400, 604800, 1209600, 1814400, 2419200, 3024000, 3628800, 4233600, 4838400, 5443200, 6048000);
  $ageoptions = drupal_map_assoc($times, 'format_interval');

  $form['station_archive_import'] = array(
    '#type' => 'fieldset',
    '#title' => t('Import'),
    '#collapsible' => FALSE,
  );
  $form['station_archive_import']['station_archive_import_new'] = array(
    '#type' => 'checkbox',
    '#title' => t('Import new audio'),
    '#default_value' => variable_get('station_archive_import_new', 1),
    '#description' => t("If this is checked, audio files left in the import directory will be added to the archive. The only reason to uncheck this is if you're running into a bug and want to stop imports until it can be fixed."),
  );
  $form['station_archive_import']['station_archive_import_dir'] = array(
    '#type' => 'textfield',
    '#title' => t('Import path'),
    '#default_value' => variable_get('station_archive_import_dir', drupal_get_path('module', 'station_archive') .'/import'),
    '#after_build' => array('system_check_directory'),
    '#required' => TRUE,
    '#description' => t('The directory where new MP3s are left by the stream ripper script. Drupal will need to have write access to this directory so we can move the file.'),
  );
  $form['station_archive_import']['station_archive_promote_scheduled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Promote scheduled audio'),
    '#default_value' => variable_get('station_archive_promote_scheduled', 1),
    '#description' => t("If this is checked, audio nodes recorded during scheduled programs will be promoted to the front page."),
  );
  $form['station_archive_import']['station_archive_delete_unscheduled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Discard unscheduled audio'),
    '#default_value' => variable_get('station_archive_delete_unscheduled', 0),
    '#description' => t("If this is checked, any audio recorded during a time with no program scheduled, rather than importing it, it will be deleted."),
  );
  $form['station_archive_import']['station_archive_unscheduled_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Default title for unscheduled audio'),
    '#default_value' => variable_get('station_archive_unscheduled_title', t('DJ Auto mix')),
    '#required' => TRUE,
    '#description' => t("This value will be used as the default title if any recordings during unscheduled times are imported."),
  );

  $form['station_archive_cleanup'] = array(
    '#type' => 'fieldset',
    '#title' => t('Clean up'),
    '#collapsible' => FALSE,
  );
  $form['station_archive_cleanup']['station_archive_cleanup_old'] = array(
    '#type' => 'checkbox',
    '#title' => t('Remove old audio'),
    '#default_value' => variable_get('station_archive_cleanup_old', 1),
    '#description' => t("If this is checked, audio that's older than the maximum age will be removed."),
  );
  $form['station_archive_cleanup']['station_archive_max_age'] = array(
    '#type' => 'select',
    '#title' => t('Maximum age'),
    '#default_value' => variable_get('station_archive_max_age', 604800),
    '#options' => $ageoptions,
    '#description' => t("Audio that's been in the archive longer than this will be removed."),
    '#required' => TRUE,
  );

  $form['module_cvs_id'] = array(
    '#type' => 'item',
    '#value' => '<pre>'. STATION_ARCHIVE_CVS_ID .'</pre>',
  );

  return system_settings_form($form);
}

/**
 * Implementation of hook_nodeapi().
 */
function station_archive_nodeapi(&$node, $op, $teaser, $page) {
  if ($node->type == 'audio'){

    switch ($op) {
      case 'prepare':
        // if they clicked the button, reload the program information
        if (t('Reload Program') == $_POST['op']) {
          // use the create timestamp as the
          $gmt_timestamp = (integer) $node->created;
          // get a timestamp that's correct for the timezone
          $local_timestamp = station_local_ts($gmt_timestamp);
          $prettydate = date('ga \o\n M jS, Y', $local_timestamp);

          // connect to the station module and find program info based on timestamp
          $program = station_get_program_at($gmt_timestamp);
          if ($program === FALSE) {
            // couldn't get the program info, configuation error?
            drupal_set_error(t("Couldn't load the program metadata from the schedule."));
            break;
          }
          elseif ($program === NULL) {
            // nothing is scheduled...
            // if we've got no program use the default metadata
            $program_nid = 0;
            $audio_tags['title'] = variable_get('station_archive_unscheduled_title', t('DJ Auto mix'));
          }
          else {
            // we've got program information
            $program_nid = $program->nid;
            $audio_tags['title'] = $program->title;
            $audio_tags['artist'] = station_anded_list($program->djs);
            $audio_tags['genre'] = $program->genre;
            $audio_tags['url_source'] = $program->node_url;
          }
          $audio_tags['year'] = date('Y', $local_timestamp);
          $audio_tags['comment'] = t('Recorded at @date', array('@date' => $prettydate));

          // audio metadata tags
          $_POST['edit']['audio_tags'] = $audio_tags;
          // archive program nid (this won't work if there isn't already a copy
          // of the program in station_archive_program).
          $_POST['edit']['station_archive']['program_nid'] = $program_nid;
          // taxonomy
          $vid = _station_archive_get_vid();
          $_POST['edit']['taxonomy'][$vid] = _station_archive_get_taxonomy($local_timestamp);
          // promotion
          $_POST['edit']['promote'] = (int) ($program && variable_get('station_archive_promote_scheduled', 1));

          drupal_set_message(t("The program information has been reloaded from the schedule. Verify that it is correct and save the changes."));
        }
        break;

      case 'validate':
        break;

      case 'update':
        if (isset($node->station_archive) && user_access('administer archive')) {
          // If there was an existing import time use that, if not use the
          // current time.
          $imported = db_result(db_query('SELECT imported AS imported FROM {station_archive} WHERE audio_nid = %d', $node->nid));
          $imported = !empty($imported) ? $imported : time();

          // Remove any existing records and if this is in the archive, create
          // a new record.
          db_query("DELETE FROM {station_archive} WHERE audio_nid = %d", $node->nid);
          if ($node->station_archive['archived']) {
            db_query("INSERT INTO {station_archive} (audio_nid, program_nid, imported, permanent) VALUES (%d, %d, %d, %d)", $node->nid, $node->station_archive['program_nid'], $imported, $node->station_archive['permanent']);
          }
        }
        break;

      case 'delete':
        // remove our tracking records when the audio node is deleted. we only
        // assume that audio node are on this machine, the program nodes could
        // be on a remote server.
        db_query('DELETE FROM {station_archive} WHERE audio_nid = %d', $node->nid);
        break;

      case 'load':
        // Sneak the '1 AS archived' in so we've got a value to indicate that
        // this node is in the archive. 
        $row = db_fetch_array(db_query("SELECT 1 AS archived, sa.program_nid, sap.title AS program_title, sa.imported, sa.permanent FROM {station_archive} sa LEFT OUTER JOIN {station_archive_program} sap ON sa.program_nid = sap.program_nid WHERE sa.audio_nid = %d", $node->nid));
        if ($row) {
          return array('station_archive' => $row);
        }
        break;

      case 'view':
        // If it's in the archives, set the menu appropriately
        if ($page && !$teaser && isset($node->station_archive)) {
          $breadcrumb[] = array('path' => 'station', 'title' => t('Station'));
          $breadcrumb[] = array('path' => 'station/archives', 'title' => t('Archives'));
          $breadcrumb[] = array('path' => 'station/archives/'. $node->station_archive['program_nid'], 'title' => $node->station_archive['program_title']);
          $breadcrumb[] = array('path' => 'node/'. $node->nid);
          menu_set_location($breadcrumb);

          // Provide information to admins on the import and deletion dates.
          if (user_access('administer archive')) {
            $node->content['station_archive'] = array(
              '#type' => 'fieldset',
              '#title' => t('Station Archive Admin Info'),
              '#collapsible' => TRUE,
              '#collapsed' => TRUE,
              station_archive_node_info_form($node),
            );
          }
        }

        break;
    }
  }
}

/**
 * Get an array containing information about programs.
 *
 * @return
 *   An array keyed by program ID, with each program stored as an object.
 */
function station_archive_get_programs() {
  $programs = array();
  $result = db_query('SELECT sap.program_nid AS nid, sap.title FROM {station_archive_program} sap ORDER BY sap.title');
  while ($obj = db_fetch_object($result)) {
    $programs[$obj->nid] = $obj;
  }
  return $programs;
}


/**
 * Implementation of hook_form_alter().
 */
function station_archive_form_alter($form_id, &$form) {
  // We only alter audio node edit forms
  if ($form_id == 'audio_node_form') {
    $node = $form['#node'];

    if (isset($node->station_archive) || user_access('administer archive')) {
      $form['station_archive'] = array(
        '#type' => 'fieldset',
        '#title' => t('Station Archive'),
        '#collapsible'=> TRUE,
        '#weight' => -5,
        '#tree' => TRUE,
        station_archive_node_info_form($node),
      );
      if (user_access('administer archive')) {
        $program_options = array();
        foreach (station_archive_get_programs() as $nid => $program) {
          $program_options[$nid] = $program->title;
        }

        $form['station_archive']['archived'] = array(
          '#type' => 'checkbox',
          '#title' => t('In Station Archive'),
          '#default_value' => $node->station_archive['archived'],
          '#description' => t("If this is checked, this then the station archive module will associate this with a program."),
          '#weight' => -1,
        );
        $form['station_archive']['program_nid'] = array(
          '#type' => 'select',
          '#title' => t('Recording of'),
          '#default_value' => $node->station_archive['program_nid'],
          '#options' => $program_options,
          '#description' => t('Select the program that this audio is a recording of.')
        );
        $form['station_archive']['refresh'] = array(
          '#type' => 'fieldset',
          '#title' => t('Reload program information'),
          '#description' => t("This lets you refresh the information about which program was playing at this time. This can be useful when the program information was incorrectly retreived or retreived before changes were made to the schedule."),
        );
        // put a reload button on the form so the admin can refresh program
        // information that was retreived incorrectly or before changes were
        // made to the schedule. this is processed in station_archive_nodeapi()
        // under the $op == 'prepare'.
        $form['station_archive']['refresh']['reload'] = array(
          '#type' => 'button',
          '#value' => t('Reload Program'),
        );
        $form['station_archive']['permanent'] = array(
          '#type' => 'checkbox',
          '#title' => t('In permanent archive'),
          '#default_value' => $node->station_archive['permanent'],
          '#description' => t("If this is checked, this recording will not be deleted during the Station Archive's clean up of old recordings."),
        );
      }
    }
  }
}

/**
 * Create form elements to display the station archive information for an audio
 * node.
 * 
 * @param $node
 *   Audio node object.
 * @return
 *   Array of form information.
 */
function station_archive_node_info_form($node) {
  if (isset($node->station_archive)) {
    $form['station_archive']['imported'] = array(
      '#type' => 'item',
      '#title' => t('Imported on'),
      '#value' => format_date($node->station_archive['imported'], 'large'),
      '#description' => t('This is the date the audio was actually imported to the archive.'),
      '#weight' => 0,
    );
    if (variable_get('station_archive_cleanup_old', 1)) {
      if ($node->station_archive['permanent']) {
        $form['station_archive']['deletion'] = array(
          '#type' => 'item',
          '#title' => t('Deletion not scheduled'),
          '#description' => t("This audio is currently in the permanent archive and will not be removed as part of the normal cleanup process."),
          '#weight' => 1,
        );
      }
      else {
        $max_age = variable_get('station_archive_max_age', 604800);
        $delete = $node->station_archive['imported'] + $max_age;
        $form['station_archive']['deletion'] = array(
          '#type' => 'item',
          '#title' => t('Deletion scheduled for'),
          '#value' => format_date($delete, 'large'),
          '#description' => t("The administrator has specified that archived recordings will be removed after being posted for %interval.", array('%interval' => format_interval($max_age))),
          '#weight' => 1,
        );
      }
    }
  }
  return $form;
}

/**
 * Implementation of hook_cron().
 *
 * Remove old files, import new ones.
 */
function station_archive_cron() {
  // HACK: we overwrite the user so that the cron user can get around the
  // permissions check and delete old audio nodes.
  global $user;
  $olduser = $user;
  $user = user_load(array('uid' => 1));

  if (variable_get('station_archive_cleanup_old', 1) == 1) {
    _station_archive_delete_old_nodes();
  }
  if (variable_get('station_archive_import_new', 1) == 1) {
    _station_archive_import_files();
  }

  _station_archive_update_program_list();

  // restore the old user so we don't screw something else up in the cron run
  $user = $olduser;
}

/**
 * Find and delete old archived audio nodes.
 *
 * We need to make sure we only delete nodes created by this module. So, we
 * search look at nodes included in our taxonomy.
 */
function _station_archive_delete_old_nodes() {
  $cutoff = time() - variable_get('station_archive_max_age', 604800);
  $result = db_query('SELECT n.nid, n.title FROM {node} n INNER JOIN {station_archive} sa ON n.nid = sa.audio_nid WHERE sa.permanent = 0 AND sa.imported < %d', $cutoff);
  while ($node = db_fetch_object($result)) {
    watchdog('stationarchive', t('Removing %title from the archive.', array('%title' => $node->title)), WATCHDOG_NOTICE);
    node_delete($node->nid);
  }
}

/**
 * Scan the import directory looking for MP3s to import.
 */
function _station_archive_import_files() {
  // locate new mp3s in the import directory
  if ($dirpath = variable_get('station_archive_import_dir', drupal_get_path('module', 'station_archive') .'/import')) {
    $files = file_scan_directory($dirpath, '[0-9]+\.(mp3|ogg)$');
    foreach ($files as $file) {
      // try to avoid php's script timeout with a bunch of large files or
      // a slow machine
      set_time_limit(0);

      $cuefile = dirname($file->filename) .'/'. $file->name .'.cue';
      // if there's a .cue file, it's still being downloaded, we'll get it on
      // the next cron call.
      if (!file_exists($cuefile)) {
        $status = _station_archive_add_file($file);
        // if there was a problem stop the import
        if (!$status) {
          return;
        }
      }
    }
  }
}

/**
 * Update the entries in the {station_archive_program} table.
 *
 * Views uses the {station_archive_program} to group audio nodes to what may be
 * remote programs. This function keeps it up to date. 
 */
function _station_archive_update_program_list() {
  // Use the local schedule if one is available.
  if (module_exists('station_schedule')) {
    $programs = station_schedule_get_program_list();
  }
  else {
    // Try to connect to a remote schedule via XMLRPC for program information.
    // If they haven't provided a url we can't retreive any data.
    if (!$url = variable_get('station_remote_schedule_url', '')) {
      return FALSE;
    }
    $programs = xmlrpc(check_url($url .'/xmlrpc.php'), 'station.program.get.list');
    if (xmlrpc_errno()) {
      watchdog('station_archive', t('Failed to load program listing remotely. Error %code : %message', array('%code' => xmlrpc_errno(), '%message' => xmlrpc_error_msg())), WATCHDOG_ERROR);
      return FALSE;
    }
  }
  foreach ($programs as $program) {
    db_query("DELETE FROM {station_archive_program} WHERE program_nid = %d", $program_nid);
    db_query("INSERT INTO {station_archive_program} (program_nid, title) VALUES (%d, '%s')", $program['nid'], $program['title']);
  }
}

/**
 * Add a file to the archive.
 *
 * Create an audio node for an mp3 or ogg file that is named with an hour's
 * timestamp. Use the timestamp to load the program information.
 *
 * @param $file
 *   Drupal file object.
 * @return
 *   Boolean indicating success.
 */
function _station_archive_add_file($file) {
  // extract the timestamp from the filename (should be simply timestamp.mp3)
  $basename = explode('.', $file->basename);
  $gmt_timestamp = $basename[0];
  $file_format = $basename[1];
  // get a timestamp that's correct for the timezone
  $local_timestamp = station_local_ts($gmt_timestamp);
  $prettydate = date('ga \o\n M jS, Y', $local_timestamp);

  // connect to the station module and find program info based on timestamp
  $program = station_get_program_at($gmt_timestamp);
  if ($program === FALSE) {
    // couldn't get the program info, configuation error?
    watchdog('stationarchive', t("Couldn't load the program metadata. We'll retry the import on the next cron run."), WATCHDOG_WARNING);
    return FALSE;
  }
  elseif ($program == NULL) {
    // nothing is scheduled...
    // ...check if they've elected to delete unscheduled programs, do so.
    if (variable_get('station_archive_delete_unscheduled', 0)) {
      file_delete($file->filename);
      watchdog('stationarchive', t('Deleted audio that was recorded during unscheduled time. Filename %filename', array('%filename' => $file->filename)), WATCHDOG_NOTICE);
      return TRUE;
    }
    // if we've got no program use the default metadata
    $program_nid = 0;
    $program_title = variable_get('station_archive_unscheduled_title', t('DJ Auto mix'));
  }
  elseif (!$program->may_archive) {
    // The program scheduled at this time is marked as non-archivable. We'll
    // delete the file and log it.
    file_delete($file->filename);
    watchdog('stationarchive', t('Deleted %program-title, it was marked as non-archivable.', array('%program-title' => $program->title)), WATCHDOG_NOTICE);
    return TRUE;
  }
  else {
    // we've got program information
    $program_nid = $program->nid;
    $program_title = $program->title;
    $audio_tags['artist'] = station_anded_list($program->djs);
    $audio_tags['genre'] = $program->genre;
    $audio_tags['url_source'] = $program->node_url;
  }
  $audio_tags['title'] = $program_title;
  $audio_tags['year'] = date('Y', $local_timestamp);
  $audio_tags['comment'] = t('Recorded at @date', array('@date' => $prettydate));

  // then create a new audio node with it
  $node = audio_api_insert($file->filename, '!title', $audio_tags);

  // make any other changes to the node...
  $node->audio_fileinfo['downloadable'] = 1;
  $node->created = $gmt_timestamp;
  // find/create the proper taxonomic terms based on day and hour
  $node->taxonomy = _station_archive_get_taxonomy($local_timestamp);
  // don't bother to check for promotion if there's no metadata
  $node->promote = (int) ($program && variable_get('station_archive_promote_scheduled', 1));
  // keep the timestamp as the filename so we can re-import again if needed but
  // store a more readable filename for the user.
  $prettyname = str_replace(' ', '_', $audio_tags['title'] ." ($prettydate).$file_format");
  $node->audio_file->origname = $prettyname;

  // ... and save it
  node_save($node);

  // record an association of the audio and program node ids and the time it was imported.
  db_query("INSERT INTO {station_archive} (audio_nid, program_nid, imported) VALUES (%d, %d, %d)", $node->nid, $program_nid, time());

  watchdog('stationarchive', t('Added %title to the archive.', array('%title' => $program_title)), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));

  return TRUE;
}

/**
 * Find/create the term ids for a day and hour based on a timestamp.
 *
 * @param $local_timestamp
 *   A timestamp that's been adjusted for the local timezone. see station_local_ts().
 * @return
 *   Array with day and hour terms.
 */
function _station_archive_get_taxonomy($local_timestamp) {
  $vid = _station_archive_get_vid();
  $day = date('w', $local_timestamp);
  $hour = date('G', $local_timestamp);

  $dayterm = _station_archive_get_day_term($vid, $day);
  if (!$dayterm) {
    $dayterm = array('vid' => $vid, 'name' => station_day_name($day),'weight' => $day - 7);
    taxonomy_save_term($dayterm);
  }

  $hourterm = _station_archive_get_hour_term($dayterm, $hour);
  if (!$hourterm) {
    $hourterm = array('vid' => $dayterm['vid'], 'parent' => $dayterm['tid'], 'name' => station_hour_name($hour), 'weight' => $hour);
    taxonomy_save_term($hourterm);
  }

  return array($dayterm['tid'], $hourterm['tid']);
}

/**
 * Find or create a Station Archive vocabulary ID.
 *
 * @return
 *   Vocabulary ID.
 */
function _station_archive_get_vid() {
  $vid = variable_get('station_archive_vid', '');
  if (empty($vid)) {
    // Check to see if a stationarchive vocabulary exists
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module = '%s'", 'stationarchive'));
    if (!$vid) {
      $vocab = array(
        'name' => 'Station Archive',
        'description' => t("This vocabulary is used by the Station Archive module to track the audio nodes it has added."),
        'help' => t("Do not add nodes to this vocabulary unless you want the station archive module to delete them when they're older than the maximum archive age."),
        'multiple' => 1,
        'required' => 0,
        'hierarchy' => 1,
        'relations' => 0,
        'module' => 'stationarchive',
        'nodes' => array('audio' => 1),
      );
      taxonomy_save_vocabulary($vocab);
      $vid = $vocab['vid'];
    }
    variable_set('station_archive_vid', $vid);
  }
  return $vid;
}

/**
 * Implementation of hook_taxonomy().
 * 
 * Delete our vocabulary variable if the vocabulary is deleted.
 */
function station_archive_taxonomy($op, $type, $object = NULL) {
  if ($op == 'delete' && $type == 'vocabulary' && $object->vid == _station_archive_get_vid())  {
    variable_del('station_archive_vid');
  }
}

/**
 * Give a string with hours return an array of vocabulary term ids for the
 * given hours.
 *
 * @param $vid
 *   integer vocabulary id
 * @param $hour_string
 *   string with hours values, integers from 1 to 168 separated by spaces
 */
function _station_archive_get_hour_tids($vid, $hour_string = '') {
  $ids = array();
  foreach (explode(' ', $hour_string) as $id) {
    $id = (integer) $id;
    if ($id > 0 && $id <= 24*7) {
      $ids[] = $id;
    }
  }
  sort($ids);

  $tids = array();
  foreach ($ids as $id) {
    $day = (integer) (($id - 1) / 24);
    $hour = ($id - 1) % 24;

    if ($dayterm = _station_archive_get_day_term($vid, $day)) {
      if ($hourterm = _station_archive_get_hour_term($dayterm, $hour)) {
        $tids[] = $hourterm['tid'];
      }
    }
  }

  return $tids;
}

/**
 * Find the taxonomy term for a day.
 *
 * @param $vid
 *   Our vocabulary ID.
 * @param $day
 *   Integer day between 0 and 6.
 * @return
 *   Array with a day's taxonomy term, FALSE if it doesn't exist.
 */
function _station_archive_get_day_term($vid, $day) {
  $dayname = station_day_name($day);
  $result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE t.vid = %d AND LOWER('%s') LIKE LOWER(name)", 't', 'tid'), array($vid, trim($dayname)));
  return db_fetch_array($result);
}

/**
 * Find or create taxonomy term for a day.
 *
 * @param $dayterm
 *   Array day taxonomy term.
 * @param $hour
 *   Integer hour between 0 and 23.
 * @return
 *   Array with an hour's taxonomy term, false if it doesn't exist.
 */
function _station_archive_get_hour_term($dayterm, $hour) {
  $hourname = station_hour_name($hour);
  $result = db_query(db_rewrite_sql("SELECT d.tid, d.* FROM {term_data} d INNER JOIN {term_hierarchy} h ON d.tid = h.tid WHERE d.vid = %d AND h.parent = %d AND LOWER('%s') LIKE LOWER(name)", 't', 'tid'), array($dayterm['vid'], $dayterm['tid'], trim($hourname)));
  return db_fetch_array($result);
}

