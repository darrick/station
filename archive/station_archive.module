<?php

/**
 * Implements hook_help().
 */
function station_archive_help($section = '') {
  switch ($section) {
    case 'admin/config/station/archive':
      return t("These settings let you configure the way the station's webstream is archived into audio nodes. Audio is imported into the archive as part of Drupal's cron task. You'll need to ensure that that is properly configured.");
  }
}

/**
 * Implements hook_menu().
 */
function station_archive_menu() {
  // Legacy menu items. This functionality is handled by Views now. These are
  // disabled by default. If you really need them you'll have to set the
  // variable by hand.
  if (variable_get('station_archive_legacy_urls', FALSE)) {
    $items['last'] = array(
      'title' => 'Show archive',
      'page callback' => 'station_archive_view_html',
      'access arguments' => array('access content'),
      'file' => 'station_archive.legacy_pages.inc',
      'type' => MENU_CALLBACK,
    );
    $items['last/hours'] = array(
      'page callback' => 'station_archive_view_hours_html',
      'access arguments' => array('access content'),
      'file' => 'station_archive.legacy_pages.inc',
      'type' => MENU_CALLBACK,
    );
    $items['rss'] = array(
      'title' => 'RSS show archive',
      'page callback' => 'station_archive_view_rss',
      'access arguments' => array('access content'),
      'file' => 'station_archive.legacy_pages.inc',
      'type' => MENU_CALLBACK,
    );
    $items['rss/hours'] = array(
      'page callback' => 'station_archive_view_hours_rss',
      'access arguments' => array('access content'),
      'file' => 'station_archive.legacy_pages.inc',
      'type' => MENU_CALLBACK,
    );
  }

  $items['admin/config/station/archive'] = array(
    'title' => 'Archive',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('station_archive_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'station_archive.admin.inc',
    //'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function station_archive_permission() {
  return array(
    'administer station archive' => array(
      'title' => t('administer station archive'),
    ),
  );
}

/**
 * Implements hook_node_update().
 */
function station_archive_node_update($node) {
  if ($node->type == 'audio') {
    if (isset($node->station_archive) && user_access('administer station archive')) {
      // Remove any existing records.
      db_delete('station_archive_item')
        ->condition('audio_nid', $node->nid)
        ->execute();
      // If this should be in the archive, create a new record.
      if ($node->station_archive['archived']) {
        if (empty($node->station_archive['aired'])) {
          $node->station_archive['aired'] = (integer) $node->created;
        }
        if (empty($node->station_archive['imported'])) {
          $node->station_archive['imported'] = REQUEST_TIME;
        }
        $record = array_merge($node->station_archive, array('audio_nid' => $node->nid));
        drupal_write_record('station_archive_item', $record);
      }
    }
  } 
}

/**
 * Implements hook_node_delete().
 */
function station_archive_node_delete($node) {
  if ($node->type == 'audio') {
    // remove our tracking records when the audio node is deleted. we only
    // assume that audio node are on this machine, the program nodes could
    // be on a remote server.
    db_delete('station_archive_item')
      ->condition('audio_nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_node_load().
 */
function station_archive_node_load($nodes, $types) {
  // Sneak the '1 AS archived' in so we've got a value to indicate that
  // this node is in the archive.
  if (in_array('station_archive', $types)) {
    foreach ($nodes as $node) {
    if ($node->type == 'station_archive') {
        //$result = db_query("SELECT 1 AS archived, sa.program_nid, sa.aired, sap.title AS program_title, sa.imported, sa.permanent FROM {station_archive_item} sa LEFT OUTER JOIN {station_archive_program} sap ON sa.program_nid = sap.program_nid WHERE sa.audio_nid = :sa.audio_nid", array(':sa.audio_nid' => $node->nid));
        $query = db_select('station_archive_item', 'sa');
        $query->fields('sa', array('program_nid', 'aired', 'imported', 'permanent'));
        $query->leftJoin('station_archive_program', 'sap', 'sa.program_nid = sap.program_nid');
        $query->fields('sap', array('title'));
	$query->condition('sa.audio_nid', $node->nid);
        $result = $query->execute();
	$result = $result->fetchAssoc();
        if ($result) {
          $result['archived'] = 1;
          $node->station_archive = $result;
        }
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function station_archive_node_view($node, $view_mode, $langcode) {
  if ($node->type == 'station_archive') {
    // If it's in the archives, set the menu appropriately
    if ($view_mode != 'teaser' && isset($node->station_archive)) {
      $breadcrumb = array(
        l(t('Home'), NULL),
        l(t('Station'), 'station'),
        l(t('Archives'), 'station/archives'),
        l($node->station_archive['program_title'], 'station/archives/' . $node->station_archive['program_nid']),
      );
      drupal_set_breadcrumb($breadcrumb);

      // Provide information to admins on the import and deletion dates.
      if (user_access('administer station archive')) {
        $node->content['station_archive'] = array(
          '#type' => 'fieldset',
          '#title' => t('Station Archive Admin Info'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE, 
          station_archive_node_info_form($node),
        );
      }
    }
  }
}

/**
 * Get an array containing information about programs.
 *
 * @return
 *   An array keyed by program ID, with each program stored as an object.  
 */
function station_archive_get_programs() {
  $programs = array();
  $result = db_query('SELECT sap.program_nid AS nid, sap.title FROM {station_archive_program} sap ORDER BY sap.title');
  //while ($obj = $result->fetch) {
  foreach ($result as $obj) {
    $programs[$obj->nid] = $obj;
  }
  return $programs;
}

/**
 * Implements hook_form_alter().
 */
function station_archive_form_alter(&$form, &$form_state, $form_id) {
  // We only alter audio node edit forms
  if ($form_id == 'station_archive_node_form') {
    $node = $form['#node'];

    if (isset($node->station_archive) || user_access('administer station archive')) {
      $form['station_archive'] = array(
        '#type' => 'fieldset',
        '#title' => t('Station Archive'),
        '#collapsible' => TRUE,
        '#collapsed' => (empty($node->station_archive['archived']) || !isset($node->audio_file)),
        '#weight' => -5,
        '#tree' => TRUE, 
        station_archive_node_info_form($node),
      );
      if (user_access('administer station archive')) {
        $program_options = array();
        foreach (station_archive_get_programs() as $nid => $program) {
          $program_options[$nid] = $program->title;
        }
        $form['station_archive']['archived'] = array(
          '#type' => 'checkbox',
          '#title' => t('In Station Archive'),
          '#default_value' => empty($node->station_archive['archived']) ? FALSE : TRUE,
          '#description' => t("If this is checked, this then the station archive module will associate this with a program."),
          '#weight' => -1,
        );
        $form['station_archive']['program_nid'] = array(
          '#type' => 'select',
          '#title' => t('Recording of'),
          '#options' => $program_options,
          '#default_value' => empty($node->station_archive['program_nid']) ? NULL : $node->station_archive['program_nid'],
          '#description' => t('Select the program that this audio is a recording of.'),
        );
        $form['station_archive']['refresh'] = array(
          '#type' => 'fieldset',
          '#title' => t('Reload program information'),
          '#description' => t("This lets you refresh the information about which program was playing at this time. This can be useful when the program information was incorrectly retreived or retreived before changes were made to the schedule."),
        );
        // put a reload button on the form so the admin can refresh program
        // information that was retreived incorrectly or before changes were
        // made to the schedule. this is processed in station_archive_nodeapi()
        // under the $op == 'prepare'.
        $form['station_archive']['refresh']['reload'] = array(
          '#type' => 'button',
          '#value' => t('Reload Program'),
        );
        $form['station_archive']['permanent'] = array(
          '#type' => 'checkbox',
          '#title' => t('In permanent archive'),
          '#default_value' => empty($node->station_archive['permanent']) ? FALSE : TRUE,
          '#description' => t("If this is checked, this recording will not be deleted during the Station Archive's clean up of old recordings."),
        );
        $form['#validate'][] = 'station_archive_node_form_custom_validate';
      }
    }
  }
}

/**
 * Custom validation function for station_archive_node_form.
 */
function station_archive_node_form_custom_validate(&$form, &$form_state) {
  // If they clicked the button, reload the program information
  if (isset($form_state['clicked_button']['#value']) && t('Reload Program') == $form_state['clicked_button']['#value']) {
    $gmt_timestamp = isset($form_state['values']['station_archive']['aired']) ? $form_state['values']['station_archive']['aired'] : REQUEST_TIME;
    // get a timestamp that's correct for the timezone
    $local_timestamp = station_local_ts($gmt_timestamp);
    $prettydate = date('ga \o\n M jS, Y', $local_timestamp);

    // connect to the station module and find program info based on timestamp
    $schedule = station_default_schedule();
    $program = station_get_program_at($gmt_timestamp, $schedule['nid']);
    if ($program === FALSE) {
      // couldn't get the program info, configuation error?
      drupal_set_error(t("Couldn't load the program metadata from the schedule."));
      break;
    }
    elseif ($program === NULL) {
      // nothing is scheduled...
      // if we've got no program use the default metadata
      $program_nid = 0;
      $audio_tags['title'] = variable_get('station_archive_unscheduled_title', t('DJ Auto mix'));
    }
    else {
      // we've got program information
      $djs = array();
      if (!empty($program->field_station_program_dj)) {
        //foreach ($program->field_station_program_dj as $entry) {
        foreach (field_get_items('node', $program, 'field_station_program_dj', $form->language) as $entry) {
          $user = user_load($entry);
          $djs[] = $user->name;
        }
      }
      $genre = field_get_items('node', $program, 'station_program_genre', $form->language);
      $program_nid = $program->nid;
      $audio_tags['title'] = $program->title;
      $audio_tags['artist'] = station_anded_list($djs);
      $audio_tags['genre'] = isset($genre[0]['value']) ? $genre[0]['value'] : '';
      $audio_tags['url_source'] = $program->node_url;
    }
    $audio_tags['year'] = date('Y', $local_timestamp);
    $audio_tags['comment'] = t('Recorded at @date', array('@date' => $prettydate));

    // audio metadata tags
    $form_state['values']['audio_tags'] = $audio_tags;
    // archive program nid (this won't work if there isn't already a copy
    // of the program in station_archive_program).
    $form_state['values']['station_archive']['program_nid'] = $program_nid;
    // taxonomy
    $vid = _station_archive_get_vid();
    $form_state['values']['taxonomy'][$vid] = _station_archive_get_taxonomy($local_timestamp);
    // promotion
    $form_state['values']['promote'] = (int) ($program && variable_get('station_archive_promote_scheduled', 1));

    drupal_set_message(t("The program information has been reloaded from the schedule. Verify that it is correct and save the changes."));
  }
}

/**
 * Create form elements to display the station archive information for an audio
 * node.
 *
 * @param $node
 *   Audio node object.
 * @return
 *   Array of form information.
 */
function station_archive_node_info_form($node) {
  $form = array();
  if (isset($node->station_archive)) {
    $form['station_archive']['aired'] = array(
      '#type' => 'item',
      '#title' => t('Air date'),
      '#value' => format_date($node->station_archive['aired'], 'long'),
      '#description' => t("The date the program first aired."),
      '#weight' => -1,
    );
    $form['station_archive']['imported'] = array(
      '#type' => 'item',
      '#title' => t('Imported on'),
      '#value' => format_date($node->station_archive['imported'], 'long'),
      '#description' => t('This is the date the audio was actually imported to the archive.'),
      '#weight' => 0,
    );
    if (variable_get('station_archive_cleanup_old', 1)) {
      if ($node->station_archive['permanent']) {
        $form['station_archive']['deletion'] = array(
          '#type' => 'item',
          '#title' => t('Deletion not scheduled'),
          '#description' => t("This audio is currently in the permanent archive and will not be removed as part of the normal cleanup process."),
          '#weight' => 1,
        );
      }
      else {
        $max_age = variable_get('station_archive_max_age', 604800);
        $delete = $node->station_archive['imported'] + $max_age;
        $form['station_archive']['deletion'] = array(
          '#type' => 'item',
          '#title' => t('Deletion scheduled for'),
          '#value' => format_date($delete, 'long'),
          '#description' => t("The administrator has specified that archived recordings will be removed after being posted for %interval.", array('%interval' => format_interval($max_age))),
          '#weight' => 1,
        );
      }
    }
  }
  return $form;
}






/**
 * Implements hook_cron().
 *
 * Remove old files, import new ones.
 */
function station_archive_cron() {
  // HACK: we overwrite the user so that the cron user can get around the
  // permissions check and delete old audio nodes.
  global $user;
  $olduser = $user;
  $user = user_load(1);

  if (variable_get('station_archive_cleanup_old', 1) == 1) {
    _station_archive_delete_old_nodes();
  }
  if (variable_get('station_archive_import_new', 1) == 1) {
    _station_archive_import_files();
  }

  _station_archive_update_program_list();

  // restore the old user so we don't screw something else up in the cron run
  $user = $olduser;
}

/**
 * Find and delete old archived audio nodes.
 *
 * We need to make sure we only delete nodes created by this module. So, we
 * search look at nodes included in our taxonomy.
 */
function _station_archive_delete_old_nodes() {
  $cutoff = REQUEST_TIME - variable_get('station_archive_max_age', 604800);
  //$result = db_query('SELECT n.nid, n.title FROM {node} n INNER JOIN {station_archive_item} sa ON n.nid = sa.audio_nid WHERE sa.permanent = :sa.permanent AND sa.imported < :sa.imported', array(':sa.permanent' => 0, ':sa.imported' => $cutoff));
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'title'));
  $query->innerJoin('station_archive_item', 'sa', 'n.nid = sa.audio_nid');
  $query->condition('sa.permanent', 0);
  $query->condition('sa.imported', $cutoff, '<');
  $result = $query->execute();
  //while ($node = db_fetch_object($result)) {
  foreach ($result as $node) {
    watchdog('stationarchive', 'Removing %title from the archive.', array('%title' => $node->title), WATCHDOG_NOTICE);
    node_delete($node->nid);
  }
}

/**
 * Scan the import directory looking for MP3s to import.
 */
function _station_archive_import_files() {
  // locate new mp3s in the import directory
  if ($dirpath = variable_get('station_archive_import_dir', drupal_get_path('module', 'station_archive') . '/import')) {
    $files = file_scan_directory($dirpath, '/[0-9]+\.(mp3|ogg)$/');
    foreach ($files as $file) {
      // try to avoid php's script timeout with a bunch of large files or
      // a slow machine
      drupal_set_time_limit(0);

      $cuefile = dirname($file->filename) . '/' . $file->name . '.cue';
      // if there's a .cue file, it's still being downloaded, we'll get it on
      // the next cron call.
      if (!file_exists($cuefile)) {
        watchdog('stationarchive', 'Attempting to import %filename into the archive.', array('%filename' => $file->filename), WATCHDOG_NOTICE);
        $status = _station_archive_add_file($file);
        // if there was a problem stop the import
        if (!$status) {
          return;
        }
      }
    }
  }
}

/**
 * Update the entries in the {station_archive_program} table.
 *
 * Views uses the {station_archive_program} to group audio nodes to what may be
 * remote programs. This function keeps it up to date.
 */
function _station_archive_update_program_list() {
  // Use the local schedule if one is available.
  if (module_exists('station_schedule')) {
    $programs = station_schedule_get_program_list();
  }
  else {
    // Try to connect to a remote schedule via XMLRPC for program information.
    // If they haven't provided a url we can't retreive any data.
    if (!$url = variable_get('station_remote_schedule_url', '')) {
      return FALSE;
    }
    $programs = xmlrpc(check_url($url . '/xmlrpc.php'), array('station.program.get.list' => array()));
    if (xmlrpc_errno()) {
      watchdog('station_archive', 'Failed to load program listing remotely. Error %code : %message', array('%code' => xmlrpc_errno(), '%message' => xmlrpc_error_msg()), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  // Insert a program for unschedule times.
  $programs[0] = array(
    'nid' => 0,
    'title' => variable_get('station_archive_unscheduled_title', t('DJ Auto mix')),
  );

  foreach ($programs as $program) {
    $program['program_nid'] = $program['nid'];
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query("DELETE FROM {station_archive_program} WHERE program_nid = %d", $program['program_nid']) */
    db_delete('station_archive_program')
      ->condition('program_nid', $program['program_nid'])
      ->execute();
    drupal_write_record('station_archive_program', $program);
  }
}

/**
 * Add a file to the archive.
 *
 * Create an audio node for an mp3 or ogg file that is named with an hour's
 * timestamp. Use the timestamp to load the program information.
 *
 * @param $file
 *   Drupal file object.
 * @return
 *   Boolean indicating success.
 */
function _station_archive_add_file($file) {
  // extract the timestamp from the filename (should be simply timestamp.mp3)
  $basename = explode('.', $file->filename);
  $gmt_timestamp = (int) $basename[0];
  $file_format = $basename[1];
  // get a timestamp that's correct for the timezone
  $local_timestamp = station_local_ts($gmt_timestamp);
  $prettydate = date('ga \o\n M jS, Y', $local_timestamp);

  // connect to the station module and find program info based on timestamp
  $schedule = station_default_schedule();
  $program = station_get_program_at($gmt_timestamp, $schedule['nid']);
  if ($program === FALSE) {
    // couldn't get the program info, configuation error?
    watchdog('stationarchive', "Couldn't load the program metadata. We'll retry the import on the next cron run.", array(), WATCHDOG_WARNING);
    return FALSE;
  }
  elseif ($program == NULL) {
    // nothing is scheduled...
    // ...check if they've elected to delete unscheduled programs, do so.
    if (variable_get('station_archive_delete_unscheduled', 0)) {
      file_delete($file);
      watchdog('stationarchive', 'Deleted audio that was recorded during unscheduled time. Filename %filename', array('%filename' => $file->filename), WATCHDOG_NOTICE);
      return TRUE;
    }
    // if we've got no program use the default metadata
    $program_nid = 0;
    $program_title = variable_get('station_archive_unscheduled_title', t('DJ Auto mix'));
  }
  elseif (!$program->may_archive) {
    // The program scheduled at this time is marked as non-archivable. We'll
    // delete the file and log it.
    file_delete($file);
    watchdog('stationarchive', 'Deleted %program-title, it was marked as non-archivable.', array('%program-title' => $program->title), WATCHDOG_NOTICE);
    return TRUE;
  }
  else {
    // we've got program information
    $program_nid = (int) $program->nid;
    $program_title = $program->title;
    $djs = array();
    if (!empty($program->field_station_program_dj)) {
      foreach (field_get_items('node', $program, 'field_station_program_dj', $form->language) as $entry) {
      //foreach ($program->field_station_program_dj as $entry) {
        $user = user_load($entry);
        $djs[] = $user->name;
      }
    }
    $genre = field_get_items('node', $program, 'station_program_genre', $form->language);
    //$audio_tags['title'] = $program->title;
    $audio_tags['artist'] = station_anded_list($djs);
    $audio_tags['genre'] = isset($genre[0]['value']) ? $genre[0]['value'] : '';
    $audio_tags['url_source'] = $program->node_url;
  }
  $audio_tags['title'] = $program_title;
  $audio_tags['year'] = date('Y', $local_timestamp);
  $audio_tags['comment'] = t('Recorded at @date', array('@date' => $prettydate));

  // find/create the proper taxonomic terms based on day and hour
  $taxonomy = _station_archive_get_taxonomy($local_timestamp);
  // then create a new audio node with it
  $title_format = variable_get('station_archive_title_format', '[audio-tag-title-raw]');
  //$node = audio_api_insert($file->filename, $title_format, '', $audio_tags, $taxonomy);
  $node = create_audio_node($file->uri, $title_format, '', $audio_tags, $taxonomy);

  // make any other changes to the node...
  $node->station_archive = array(
    'archived' => 1,
    'program_nid' => $program_nid,
    'aired' => $gmt_timestamp,
    'imported' => REQUEST_TIME,
    'permanent' => 0,
  );
  $node->audio_file['downloadable'] = 1;
  $node->created = $gmt_timestamp;
  // don't bother to check for promotion if there's no metadata
  $node->promote = (int) ($program && variable_get('station_archive_promote_scheduled', 1));
  // keep the timestamp as the filename so we can re-import again if needed but
  // store a more readable filename for the user.
  $node->audio_file['file_name'] = str_replace(' ', '_', $audio_tags['title'] . " ($prettydate).$file_format");

  // ... and save it
  $node = node_submit($node);
  node_save($node);

  watchdog('stationarchive', 'Added %title to the archive.', array('%title' => $program_title), WATCHDOG_NOTICE, l(t('view'), 'node/' . $node->nid));

  return TRUE;
}

/**
 * Create and return a station audio node object.
 */
function create_audio_node($filepath, $title_format = NULL, $body = NULL, $tags = array(), $taxonomy = array()) {
  // Create a node object, and add node properties.
  $newNode = new stdClass();
  $newNode->type = 'station_archive';
  $newNode->uid = 0;
  $newNode->created = strtotime("now");
  $newNode->changed = strtotime("now");
  $newNode->status = 1;
  $newNode->comment = 0;
  $newNode->promote = 0;
  $newNode->moderate = 0;
  $newNode->sticky = 0;
  $newNode->language = LANGUAGE_NONE;

  node_object_prepare($newNode);

  $newNode->title = $tags['title'] . (isset($tags['artist']) ? (" by " . $tags['artist']) : "");
  $newNode->field_station_archive_audio_age[LANGUAGE_NONE] = $taxonomy; 
  $audio_file = new stdClass;
  $audio_file->uid = 1;
  $audio_file->uri = $filepath;
  $audio_file->filemime = file_get_mimetype($filepath);
  $audio_file->display = 1;
  $audio_file->status = 1;
  $audio_file = file_copy($audio_file, 'public://archive');
  $newNode->field_station_archive_audio[LANGUAGE_NONE][0] = (array)$audio_file;
  return $newNode;
}


/**
 * Create audio nodes from a file.
 *
 * Function for other modules to use to create a audio node from a file. Once
 * you've created it you can make any changes and then save it using
 * node_save().
 *
 * @param $filepath
 *   Full path to an audio file. be aware that the file will be moved into
 *   drupal's directory.
 * @param $title_format
 *   An optional, token string for generating the node's title. If nothing is
 *   provided the default title format will be used.
 * @param $body
 *   An optional string to use for the node's body.
 * @param $taxonomy
 *   An optional array of taxonomy terms to assign to the node if the taxonomy
 *   module is installed.
 * @param $tags
 *   An optional array of metadata to add to the node. These will overwrite
 *   any values loaded from the ID3 tags.
 * @return
 *   A node or FALSE on error.
 */
function audio_api_insert($filepath, $title_format = NULL, $body = NULL, $tags = array(), $taxonomy = array()) {
  global $user;

  // For node_object_prepare()
  module_load_include('inc', 'node', 'node.pages');

  // Check for user permission.
  //if (!audio_access('create')) {
  //  drupal_access_denied();
  //}

  // Begin building file object.
  $file = new stdClass();
  $file->uid = $user->uid;
  $file->filepath = $filepath;
  $file->filename = basename($file->filepath);
  $file->filemime = module_exists('mimedetect') ? mimedetect_mime($file->filepath) : file_get_mimetype($file->filepath);
  $file->filesize = filesize($file->filepath);
  $file->timestamp = time();
  $file->status = FILE_STATUS_TEMPORARY;
  drupal_write_record('files', $file);

  $node = new stdClass();
  $node->nid = NULL;
  $node->type = 'audio';
  $node->uid = $user->uid;
  $node->name = $user->name;
  $node->language = '';
  $node->title = '';
  $node->title_format = $title_format;
  $node->body = $body;

  // Set the node's defaults... (copied this from node and comment.module)
  $node_options = variable_get('node_options_'. $node->type, array('status', 'promote'));
  $node->status = in_array('status', $node_options);
  $node->moderate = in_array('moderate', $node_options);
  $node->promote = in_array('promote', $node_options);
  if (module_exists('comment')) {
    $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);
  }
  if (module_exists('taxonomy') && is_array($taxonomy)) {
    $node->taxonomy = $taxonomy;
  }

  $node->audio_tags = array();
  $node->audio_images = array();

  $node->audio = array(
    'downloadable' => variable_get('audio_default_downloadable', 1),
    'play_count' => 0,
    'download_count' => 0,
    'file' => $file,
  );

  node_object_prepare($node);

  // Allow other modules to modify the node (hopefully reading in tags).
  audio_invoke_audioapi('upload', $node);

  // Add the tags (overwriting any that audio_getid3 may have loaded).
  if (is_array($tags)) {
    $node->audio_tags = array_merge($node->audio_tags, $tags);
  }

  // Build the title manually (since we don't call node_validate()).
  if (empty($node->title_format)) {
    $node->title_format = variable_get('audio_default_title_format', '[audio-tag-title-raw] by [audio-tag-artist-raw]');
  }
  // Flush the token cache, otherwise when importing multiple nodes they'll all
  // have the same title.
  token_get_values('node', $node, TRUE);
  $node->title = token_replace($node->title_format, 'node', $node);

  // Save it.
  $node = node_submit($node);
  node_save($node);

  return $node;
}




/**
 * Find/create the term ids for a day and hour based on a timestamp.
 *
 * @param $local_timestamp
 *   A timestamp that's been adjusted for the local timezone
 * @return
 *   Array with day and hour term ids.
 *
 * @see station_local_ts()
 */
function _station_archive_get_taxonomy($local_timestamp) {
  $vid = _station_archive_get_vid();
  $minute = station_minute_from_local_ts($local_timestamp);
  $time = station_time_from_minute($minute);

  $day_name = theme('station_day', array('time' => $minute));
  // TODO Please convert this statement to the D7 database API syntax.
  //$result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {taxonomy_term_data} t WHERE t.vid = %d AND LOWER('%s') LIKE LOWER(name)", 't', 'tid'), array($vid, $day_name));
  $query = db_select('taxonomy_term_data', 't');
  $query->fields('t');
  $query->condition('t.vid', $vid);
  $arguments = array(':name' => $day_name);
  $query->where('LOWER(:name) like LOWER(name)', $arguments);
  $query->addTag('node_access');
  $result = $query->execute();
  $dayterm = $result->fetch();
  if (!$dayterm) {
    $dayterm = new stdClass();
    $dayterm->vid = $vid;
    $dayterm->name = $day_name;
    $dayterm->weight = $time['w'] - 7;
    taxonomy_term_save($dayterm);
  }

  $hour_name = theme('station_hour', array('time' => $minute));
  // TODO Please convert this statement to the D7 database API syntax.
  //$result = db_query(db_rew AND h.parent = %d AND LOWER('%s') LIKE LOWER(name)", 't', 'tid'), array($vid, $dayterm['tid'], $hour_name));
  $query = db_select('taxonomy_term_data', 'd');
  $query->fields('d');
  $query->innerJoin('taxonomy_term_hierarchy', 'h', 'd.tid = h.tid');
  $query->condition('d.vid', $vid);
  $query->condition('h.parent', $dayterm->tid);
  $arguments = array(':name' => $hour_name);
  $query->where('LOWER(:name) like LOWER(name)', $arguments);
  $query->addTag('node_access');
  $result = $query->execute();
  $hourterm = $result->fetch();
  if (!$hourterm) {
    $hourterm = new stdClass();
    $hourterm->vid = $vid;
    $hourterm->parent = $dayterm->tid;
    $hourterm->name = $hour_name;
    $hourterm->weight = $time['G'];
    taxonomy_term_save($hourterm);
  }

  return array($dayterm->tid, $hourterm->tid);
}

/**
 * Find or create a Station Archive vocabulary ID.
 *
 * @return
 *   Vocabulary ID.
 */
function _station_archive_get_vid() {
  $vid = variable_get('station_archive_vid', '');
  if (empty($vid)) {
    // Check to see if a stationarchive vocabulary exists
    $vid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE module = :module", array(':module' => 'station_archive'))->fetchField();
    if (!$vid) {
      $vocab = new stdClass();
      $vocab->name = 'Station Archive';
      $vocab->machine_name = 'station_archive';
      $vocab->description = t("This vocabulary is used by the Station Archive module to track the audio nodes it has added.");
      $vocab->hierarchy = 1;
      $vocab->module = 'station_archive';
      taxonomy_vocabulary_save($vocab);
      $vid = $vocab->vid;
    }
    variable_set('station_archive_vid', $vid);
  }
  return $vid;
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 *
 * Delete our vocabulary variable if the vocabulary is deleted.
 */
function station_archive_taxonomy_vocabulary_delete($vocavulary) {
  if ($vocabulary->vid == _station_archive_get_vid()) {
    variable_del('station_archive_vid');
  }
}
