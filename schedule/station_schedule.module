<?php

define('STATION_SCHEDULE_CVS_ID', '$Id$');

if (module_exists('views')) {
  require_once(drupal_get_path('module', 'station_schedule') .'/views.inc');
  require_once(drupal_get_path('module', 'station_schedule') .'/views_defaults.inc');
}


/**
 * Display help and module information
 * @param section which section of the site we're displaying help
 * @return help text for section
 */
function station_schedule_help($section = '') {
  switch ($section) {
    case 'node/'. arg(1) .'/schedule':
      return t('Use this page to make changes to the schedule. You can select which programs air at what time.');

    case 'admin/settings/station/schedule':
      return t("These settings allow you to configure the station's schedule.");

    case 'node/'. arg(1) .'/view/'. arg(3):
      $output = '';
      if (station_has_archive()) {
        $output .= t('The !listen_img listen link will take you to the list of archived copies of a show. The !rss_img link will take you to an RSS feed of the archived copies suitable for podcasting.',
          array(
            '!listen_img' => theme('image', drupal_get_path('module', 'station_schedule') . '/images/listen_tiny.gif', 'listen'),
            '!rss_img' =>  theme('image', drupal_get_path('module', 'station_schedule') . '/images/rss_tiny.gif', 'podcast'),
          )
        );
      }
      return $output;
  }
}

function station_schedule_menu($may_cache) {
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/station/schedule',
      'title' => t('Schedule'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('station_schedule_admin_settings'),
      'access' => user_access('administer site configuration'),
      'type' => MENU_LOCAL_TASK
    );

    if (variable_get('station_schedule_redirect_old_urls', 0)) {
      $items[] = array(
        'path' => 'schedule',
        'callback' => 'station_schedule_redirect_old',
        'access' => user_access('access content'),
        'type' => MENU_CALLBACK,
      );
      $items[] = array(
        'path' => 'station/schedule',
        'callback' => 'station_schedule_redirect_old',
        'access' => user_access('access content'),
        'type' => MENU_CALLBACK,
      );
    }
  }
  else {
    // Admininister schedule nodes.
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $nid = (int) arg(1);
      $node = node_load($nid);
      if ($node->type == 'station_schedule') {
        // Stream M3U links
        foreach ($node->settings['streams'] as $key => $stream) {
          $items[] = array(
            'path' => "node/$nid/$key.m3u",
            'type' => MENU_CALLBACK,
            'callback' => 'station_schedule_stream_m3u',
            'callback arguments' => array($stream),
          );
        }

        $items[] = array(
          'path' => "node/$nid/view/week",
          'title' => t('Week'),
          'type' => MENU_DEFAULT_LOCAL_TASK,
          'weight' => -10,
        );
        // Use a separate variable to set the weights since station_day_name()
        // may return index values that are not sorted.
        $weight = 0;
        foreach (station_day_name() as $day => $dayname) {
          $items[] = array(
            'path' => "node/$nid/view/". strtolower($dayname),
            'title' => t(substr($dayname, 0, 3)),
            'callback' => 'station_schedule_day_page',
            'callback arguments' => array($node, $dayname),
            'type' => MENU_LOCAL_TASK,
            'weight' => $weight++,
          );
        }

        $items[] = array(
          'path' => "node/$nid/schedule",
          'title' => t('Alter schedule'),
          'callback' => 'station_schedule_item_list',
          'callback arguments' => array($node),
          'access' => user_access('administer schedule'),
          'type' => MENU_LOCAL_TASK,
        );
        $items[] = array(
          'path' => "node/$nid/schedule/list",
          'title' => t('View'),
          'type' => MENU_DEFAULT_LOCAL_TASK,
          'weight' => -10,
        );
        $items[] = array(
          'path' => "node/$nid/schedule/add",
          'title' => t('Add item'),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('station_schedule_item_edit_form', 'add', $node),
          'type' => MENU_LOCAL_TASK,
        );
        $items[] = array(
          'path' => "node/$nid/schedule/edit",
          'title' => t('Edit item'),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('station_schedule_item_edit_form', 'edit', $node),
          'type' => MENU_CALLBACK
        );
        $items[] = array(
          'path' => "node/$nid/schedule/remove",
          'title' => t('Remove item'),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('station_schedule_item_remove_form', $node),
          'type' => MENU_CALLBACK
        );
      }
    }
  }

  return $items;
}


/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the station module
 */
function station_schedule_perm() {
  return array(
    'administer schedule',
  );
}

/**
 * Implementation of hook_node_info().
 */
function station_schedule_node_info() {
  return array(
    'station_schedule' => array(
      'name' => t('Schedule'),
      'module' => 'station_schedule',
      'title_label' => t('Name'),
      'description' => t('A station schedule.'),
    )
  );
}

/**
 * Implementation of hook_access().
 */
function station_schedule_access($op, $node) {
  global $user;

  switch ($op) {
    case 'view':
      return user_access('access content');
      break;

    case 'update':
    case 'delete':
    case 'create':
    default:
      return user_access('administer schedule');
  }
}

/**
 * Implementation of hook_form().
 */
function station_schedule_form($node) {
  $type = node_get_types('type', $node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#default_value' => $node->title,
    '#required' => TRUE,
    '#maxlength' => 128,
    '#description' => t("The name of the schedule, e.g. 'AM', 'FM', callsign."),
  );

  $form['settings']['#tree'] = TRUE;
  $form['settings']['increment'] = array(
    '#type' => 'select',
    '#title' => t('Time increment'),
    '#default_value' => isset($node->settings['increment']) ? $node->settings['increment'] : 60,
    '#options' => array(15 => t('15 Minutes'), 30 => t('30 Minutes'), 60 => t('1 Hour'), 120 => t('2 Hours')),
    '#description' => t("This is the minimum increment that programs can be scheduled in. <strong>Caution:</strong> Increasing this value on an existing schedule will probably cause weirdness."),
  );
  $form['settings']['unscheduled_message'] = array(
    '#type' => 'textfield',
    '#title' => t('No scheduled programming message'),
    '#size' => 60,
    '#maxlength' => 255,
    '#default_value' => isset($node->settings['unscheduled_message']) ? $node->settings['unscheduled_message'] : t("We're on autopilot."),
    '#required' =>  TRUE,
    '#description' => t('This string will appear when no program is currently scheduled.'),
  );
  $form['settings']['streams'] = array(
    '#type' => 'fieldset',
    '#title' => t('Web streams'),
    '#theme' => 'station_schedule_form_streams',
    '#collapsible' => TRUE,
    '#description' => t("If your station has webstreams enter them below."),
  );
  if (!isset($node->settings['streams']['new'])) {
    $node->settings['streams']['new'] = array(
      'name' => '',
      'description' => '',
      'urls' => array(),
    );
  }
  foreach ($node->settings['streams'] as $key => $stream) {
    $form['settings']['streams'][$key]['name'] = array(
      '#type' => 'textfield',
      '#size' => 10,
      '#default_value' => $stream['name'],
    );
    $form['settings']['streams'][$key]['description'] = array(
      '#type' => 'textfield',
      '#size' => 20,
      '#default_value' => $stream['description'],
    );
    $form['settings']['streams'][$key]['urls'] = array(
      '#type' => 'textarea',
      '#rows' => 2,
      '#cols' => 20,
      '#default_value' => implode("\n", $stream['urls']),
    );
  }

  if ($type->has_body) {
    $form['body_filter']['body'] = array(
      '#type' => 'textarea',
      '#title' => check_plain($type->body_label),
      '#default_value' => $node->body,
      '#rows' => 10,
      '#required' => ($type->min_word_count > 0),
      '#description' => t("Description of the schedule."),
    );
    $form['body_filter']['format'] = filter_form($node->format);
  }

  return $form;
}


function theme_station_schedule_form_streams(&$form) {
  $header = array(t('Name'), t('Description'), t('URLs'));
  foreach (element_children($form) as $key) {
    $row = array();
    $row[] = drupal_render($form[$key]['name']);
    $row[] = drupal_render($form[$key]['description']);
    $row[] = drupal_render($form[$key]['urls']);
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);
  $output .= drupal_render($form);

  return $output;
}

/**
 * Implementation of hook_validate().
 */
function station_schedule_validate(&$node) {
  foreach ($node->settings['streams'] as $key => $stream) {
    // Must have both a name and URL.
    if (empty($stream['name']) xor empty($stream['urls'])) {
      if (empty($stream['name'])) {
        form_set_error("settings][streams][$key][name", t('You must provide a name for the webstream.'));
      }
      else {
        form_set_error("settings][streams][$key][urls", t('You must provide a URL for the webstream.'));
      }
    }

    foreach (explode("\n", $stream['urls']) as $url) {
      $url = trim($url);
      if (!empty($url) && !valid_url($url, TRUE)) {
        form_set_error("settings][streams][$key][urls", t('An invalid webstream URL was provided: %url', array('%url' => $url)));
      }
    }
  }
}

/**
 * Implementation of hook_submit().
 */
function station_schedule_submit(&$node) {
  $streams = array();
  foreach ((array) $node->settings['streams'] as $key => $stream) {
    // Skip empty rows.
    if (!empty($stream['name'])) {
      // Convert URLs into an array.
      $stream['urls'] = array_map('trim', explode("\n", $stream['urls']));
      $streams[$stream['name']] = $stream;
    }
  }
  $node->settings['streams'] = $streams;
}


/**
 * Implementation of hook_load().
 */
function station_schedule_load($node) {
  $schedule = array();
  // Use station_day_name() for the day ordering in case Sunday isn't the
  // first day of the week.
  foreach (station_day_name() as $day => $name) {
    $schedule[$day] = array();

    $start = $day * MINUTES_IN_DAY;
    $finish = $start + MINUTES_IN_DAY;
    $result = db_query('SELECT * FROM {station_schedule_item} i WHERE i.schedule_nid = %d AND i.finish > %d AND i.start < %d ORDER BY i.start', $node->nid, $start, $finish);
    while ($s = db_fetch_object($result)) {
      // If a show spans a day, limit its start and finish times to be with-in
      // the day.
      if ($s->start < $start) {
        $s->start = $start;
      }
      if ($s->finish > $finish) {
        $s->finish = $finish;
      }
      $schedule[$day][] = $s;
    }
  }

  // Load the settings.
  $settings = db_fetch_array(db_query('SELECT increment, streams, unscheduled_message FROM {station_schedule} WHERE nid = %d', $node->nid));
  if (isset($settings['streams']) && $streams = unserialize($settings['streams'])) {
    $settings['streams'] = array();
    foreach ($streams as $key => $stream) {
      // Add in the M3U URL.
      $stream['m3u_url'] = url('node/'. $node->nid .'/'. $key .'.m3u', NULL, NULL, TRUE);
      $settings['streams'][$key] = $stream;
    }
  }
  else {
    $settings['streams'] = array();
  }

  return array(
    'settings' => $settings,
    'schedule' => $schedule,
  );
}

/**
 * Implementation of hook_insert().
 */
function station_schedule_insert($node) {
  db_query("INSERT INTO {station_schedule} (nid, increment, streams, unscheduled_message) VALUES (%d, %d, '%s', '%s')", $node->nid, $node->settings['increment'], serialize($node->settings['streams']), $node->settings['unscheduled_message']);
}

/**
 * Implementation of hook_delete().
 */
function station_schedule_delete($node) {
  db_query("DELETE FROM {station_schedule_item} WHERE schedule_nid = %d", $node->nid);
  db_query("DELETE FROM {station_schedule} WHERE nid = %d", $node->nid);
}

/**
 * Implementation of hook_update().
 */
function station_schedule_update($node) {
  db_query("DELETE FROM {station_schedule} WHERE nid = %d", $node->nid);
  db_query("INSERT INTO {station_schedule} (nid, increment, streams, unscheduled_message) VALUES (%d, %d, '%s', '%s')", $node->nid, $node->settings['increment'], serialize($node->settings['streams']), $node->settings['unscheduled_message']);
}

function station_schedule_admin_settings() {
  $form['djs'] = array(
    '#type' => 'fieldset',
    '#title' => t('DJ settings'),
  );
  $form['djs']['station_schedule_dj_title'] = array(
    '#type' => 'textfield',
    '#title' => t('DJ title'),
    '#default_value' => variable_get('station_schedule_dj_title', 'DJs'),
    '#description' => t("This setting lets you determine what you'd like to call the users associated with programs. It should be plural."),
    '#required' => TRUE,
  );
  $form['djs']['station_schedule_dj_role'] = array(
    '#type' => 'select',
    '#title' => t('DJs role'),
    '#default_value' => variable_get('station_schedule_dj_role', DRUPAL_AUTHENTICATED_RID),
    '#options' => user_roles(TRUE),
    '#description' => t("This lets you restrict DJs to members of a specific role. If you don't want any restrictions, select <em>authenticated user</em>s."),
  );

  $form['bc'] = array(
    '#type' => 'fieldset',
    '#title' => t('Backwards compatibility'),
  );
  $schedules = array();
  foreach (station_get_schedules() as $nid => $schedule) {
    $schedules[$nid] = $schedule['title'];
  }
  $form['bc']['station_schedule_redirect_old_urls'] = array(
    '#type' => 'checkbox',
    '#title' => t('Redirect old links'),
    '#default_value' => variable_get('station_schedule_redirect_old_urls', 0),
    '#options' => $schedules,
    '#description' => t("Checking this will ensure that the station module continues to redirect old <code>/schedule</code> and <code>/station/schedule</code> links."),
  );
  $form['bc']['station_schedule_default'] = array(
    '#type' => 'select',
    '#title' => t('Default schedule'),
    '#default_value' => variable_get('station_schedule_default', 0),
    '#options' => $schedules,
    '#description' => t("This you select the schedule that will be used as the default for backwards compatibility."),
  );

  $form['station_schedule_program_node_type'] = array(
    '#type' => 'item',
    '#title' => t('Scheduled node type'),
    '#value' => t('The schedule is using the %type node provided by the %module module.', array('%type' => 'station_program', '%module' => node_get_types('module', 'station_program'))),
  );

  $form['module_cvs_id'] = array(
    '#type' => 'item',
    '#value' => '<pre>'. STATION_SCHEDULE_CVS_ID .'</pre>',
  );

  return system_settings_form($form);
}

/**
 * Implementation of hook_link().
 *
 * This is implemented so that an edit link is displayed for users who have
 * the rights to edit a node.
 */
function station_schedule_link($type, $node = NULL, $teaser = FALSE) {
  if ($type == 'node') {
    switch ($node->type) {
    case 'station_program':
      return station_schedule_archive_links($node->nid);
    case 'station_playlist':
      if (!$teaser && $node->program_nid) {
        return station_schedule_archive_links($node->program_nid);
      }
    }
  }
  return array();
}

/**
 * Load listen links for a program.
 * @param $program_nid Node id of the program.
 * @param $short bool true for short version of links
 */
function station_schedule_archive_links($program_nid, $short = FALSE) {
  $archive_url = station_get_archive_url();
  $may_archive = db_result(db_query('SELECT COUNT(*) FROM {station_schedule_item} s WHERE s.program_nid = %s AND s.may_archive = 1', $program_nid));

  if ($archive_url && $may_archive ) {
    $listen_url = $archive_url . $program_nid;
    $rss_url = $archive_url . $program_nid .'/feed';

    $listen_img = drupal_get_path('module', 'station_schedule') .'/images/listen_tiny.gif';
    $rss_img = drupal_get_path('module', 'station_schedule') .'/images/rss_tiny.gif';

    return array(
      'station_archive_listen' => array(
        'href' => $listen_url,
        'title' => theme('image', $listen_img, t('Listen')) . (($short) ? '' : ' '. t('Listen to previous')),
        'attributes' => array('title' => t('Listen to previous broadcasts of this show')),
        'html' => TRUE,
      ),
      'station_archive_rss' => array(
        'href' => $rss_url,
        'title' => theme('image', $rss_img, t('Podcast'))  . (($short) ? '' : ' '. t('Subscribe to podcast')),
        'attributes' => array('title' => t('Grab this show with your podcast software')),
        'html' => TRUE,
      ),
    );
  }
  return array();
}

/**
 * Implements hook_user() to associate programs with the users.
 */
function station_schedule_user($op, &$edit, &$user, $category = NULL) {
  switch ($op) {
  case 'load':
    $user->programs = array();
    $result = db_query('SELECT n.nid, n.title FROM {node} n INNER JOIN {station_dj} d ON n.nid = d.program_nid WHERE d.uid = %d ORDER BY n.title', $user->uid);
    while ($program = db_fetch_object($result)) {
      $user->programs[$program->nid] = $program->title;
    }
    break;

  case 'view':
    if ($user->programs) {
      foreach((array) $user->programs as $nid => $title) {
        $node = node_load($nid);
        $node = node_build_content($node, TRUE, FALSE);
        $items[] = array('title' => l($title, 'node/'. $nid),
          'class' => 'program',
          'value' => $node->content['genre']['#value'] . $node->content['times']['#value'],
        );
      }
      return array(t('Programs') => $items);
    }
    break;

  case 'delete':
    db_query('DELETE FROM {station_dj} WHERE uid = %d', $user->uid);
    foreach ((array) $user->programs as $nid => $title) {
      _station_send_notice('dj', 'remove', array('program_nid' => $nid, 'uid' => $user->uid));
    }
    break;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function station_schedule_nodeapi(&$node, $op, $teaser, $page) {
  if ($node->type == 'station_program') {
    switch ($op) {
      case 'validate':
        $roles = user_roles(TRUE);
        $dj_role = variable_get('station_schedule_dj_role', DRUPAL_AUTHENTICATED_RID);

        // validate the users
        foreach ($node->djs as $key => $name) {
          if (!empty($name)) {
            $user = user_load(array('name' => $name));
            if (!$user->uid) {
              form_set_error("djs][$key", t('You need to specify a valid user name.'));
            }
            if (!isset($user->roles[$dj_role])) {
              form_set_error("djs][$key", t('%username is not a member of the %rolename role.',
                  array('%username' => $name, '%rolename' => $roles[$dj_role])));
            }
          }
        }
        break;

      case 'submit':
        // make a copy of the djs and put them back in the expected form
        $djs = (array) $node->djs;
        $node->djs = array();
        foreach ($djs as $key => $name) {
          if (!empty($name)) {
            $user = user_load(array('name' => $name));
            if ($user->uid) {
              $node->djs[$user->uid] = $user->name;
            }
          }
        }
        break;

      case 'insert':
        // dj additions
        foreach ($node->djs as $uid => $username) {
          db_query('INSERT INTO {station_dj} (uid, program_nid) VALUES (%d, %d)', $uid, $node->nid);
          _station_send_notice('dj', 'add', array('program_nid' => $node->nid, 'uid' => $uid));
        }
        break;

      case 'update':
        // only schedule admins should be able to add or remove djs
        if (user_access('administer schedule')) {
          $current_djs = _station_schedule_program_load_djs($node->nid);

          // dj removals
          $removals = array_diff_assoc($current_djs, $node->djs);
          foreach ($removals as $uid => $username) {
            db_query('DELETE FROM {station_dj} WHERE uid = %d AND program_nid = %d', $uid, $node->nid);
            _station_send_notice('dj', 'remove', array('program_nid' => $node->nid, 'uid' => $uid));
          }

          // dj additions
          $additions = array_diff_assoc($node->djs, $current_djs);
          foreach ($additions as $uid => $username) {
            db_query('INSERT INTO {station_dj} (uid, program_nid) VALUES (%d, %d)', $uid, $node->nid);
            _station_send_notice('dj', 'add', array('program_nid' => $node->nid, 'uid' => $uid));
          }
        }
        break;

      case 'delete':
        // Remove the DJs and provide notice.
        $removals = _station_schedule_program_load_djs($node->nid);
        db_query('DELETE FROM {station_dj} WHERE program_nid = %d', $node->nid);
        foreach ($removals as $uid => $username) {
          _station_send_notice('dj', 'remove', array('program_nid' => $node->nid, 'uid' => $uid));
        }

        // Remove the schedule item.
        db_query('DELETE FROM {station_schedule_item} WHERE program_nid = %d', $node->nid);
        break;

      case 'load':
        // load the program's users under djs.
        $node->djs = _station_schedule_program_load_djs($node->nid);

        $node->times = array();
        // Load the schedule items in order of start time while taking into
        // account Drupal's first day of the week setting.
        $result = db_query('SELECT * FROM {station_schedule_item} s WHERE s.program_nid = %d ORDER BY s.schedule_nid, ((s.start + %d) %% %d)', $node->nid, MINUTES_IN_DAY * (7 - variable_get('date_first_day', 0)), MINUTES_IN_WEEK);
        while ($item = db_fetch_array($result)) {
          $node->times[$item['schedule_nid']][] = $item;
        }

        break;

      case 'view':
        if ($page) {
          $breadcrumb = array();
          $breadcrumb[] = array('path' => 'station/programs', 'title' => t('Programs'));
          $breadcrumb[] = array('path' => 'node/'. $node->nid);
          menu_set_location($breadcrumb);
        }

        $djs = station_schedule_program_get_themed_djs($node);
        $schedules = station_get_schedules();
        $times_by_schedule = station_schedule_program_get_themed_times($node);

        if ($teaser) {
          if ($djs) {
            $node->content['djs'] = array(
              '#value' => t(' with !djs', array('!djs' => station_anded_list($djs))),
              '#weight' => -1,
            );
          }
          $scheduled = array();
          foreach ($times_by_schedule as $schedule_nid => $times) {
            $scheduled[] = t('@title @times', array('@title' => $schedules[$schedule_nid]['title'], '@times' => station_anded_list($times)));
          }
          $node->content['times'] = array(
            '#value' => $scheduled ? t(' on @scheduling.', array('@scheduling' => station_anded_list($scheduled))) : t(' is not currently scheduled.'),
            '#weight' => 0,
          );
        }
        else {
          if ($djs) {
            $node->content['djs'] = array(
              '#type' => 'item',
              '#title' => variable_get('station_schedule_dj_title', 'DJs'),
              '#value' => theme('item_list', $djs),
              '#weight' => -5,
            );
          }
          $node->content['times']['#weight'] = -4;
          foreach ($times_by_schedule as $schedule_nid => $times) {
            $node->content['times'][$schedule_nid] = array(
              '#type' => 'item',
              '#title' => t('Listen on <a href="!link">@title</a> at', array('@title' => $schedules[$schedule_nid]['title'], '!link' => url('node/'. $schedule_nid))),
              '#value' => $times ? theme('item_list', $times) : t('This program is currently unscheduled.'),
            );
          }
        }
        break;
    }
  }
}


/**
 * implementation of hook_form_alter()
 */
function station_schedule_form_alter($form_id, &$form) {
  // We only alter audio node edit forms
  if ($form_id == 'station_program_node_form') {
    $node = $form['#node'];

    if (user_access('administer schedule')) {
      $form['schedule'] = array(
        '#type' => 'fieldset',
        '#title' => t('Station Schedule'),
        '#weight' => 1,
        '#tree' => TRUE,
        '#description' => t('The program must be saved before it can be added to the schedule.'),
        '#collapsible' => TRUE,
      );

      // if it's a saved display the scheduled times.
      if ($node->nid) {
        $schedules = station_get_schedules();

        $form['schedule']['#description'] = count($schedules) ? '' : t("There are no schedules on this site.");
        
        foreach ($schedules as $schedule_nid => $schedule) {
          $links = array();
          $form['schedule'][$schedule_nid] = array(
            '#type' => 'fieldset',
            '#title' => $schedule['title'],
            '#description' => t("These are the times this program is currently scheduled:"),
          );
          if (!isset($node->times[$schedule_nid])) {
            $form['schedule'][$schedule_nid]['#description'] = t('This program is not on this schedule.');
          }
          else {
            foreach ($node->times[$schedule_nid] as $time) {
              $links[] = l(theme('station_dayhour_range', $time['start'], $time['finish']), "node/{$schedule_nid}/schedule/edit/{$time['iid']}", array(), "destination=node/{$node->nid}/edit");
            }
          }
          // Don't encourage adding unpublished stuff to the schedule.
          if ($node->status != 0) {
            $links[] = l(t('Add this program to the @name schedule', array('@name' => $schedule[''])), "node/{$schedule_nid}/schedule/add/{$node->nid}", array(), "destination=node/{$node->nid}/edit");
          }
          $form['schedule'][$schedule_nid]['links'] = array(
            '#type' => 'item',
            '#value' => theme('item_list', $links),
          );
        }
      }

      $roles = user_roles(TRUE);
      $dj_role = variable_get('station_schedule_dj_role', DRUPAL_AUTHENTICATED_RID);
      $form['djs'] = array(
        '#type' => 'fieldset',
        '#title' => variable_get('station_schedule_dj_title', 'DJs'),
        '#weight' => 1,
        '#tree' => TRUE,
        '#description' => t("Enter the names of users you'd like to add as @dj-title. The users must be members of the %role-name role.",
            array('@dj-title' => variable_get('station_schedule_dj_title', 'DJs'), '%role-name' => $roles[$dj_role])),
      );
      if ($node->djs) {
        foreach ((array)$node->djs as $uid => $username) {
          $form['djs'][$uid] = array(
            '#type' => 'textfield', '#maxlength' => 60,
            '#autocomplete_path' => 'user/autocomplete',
            '#default_value' => $username,
          );
        }
      }
      // add some blank username textfields
      for ($i = 0; $i < 4; $i++) {
        $form['djs']['new'. $i] = array(
          '#type' => 'textfield', '#maxlength' => 60,
          '#autocomplete_path' => 'user/autocomplete',
        );
      }
    }
  }
}

/**
 * Return an array of DJ info for a given program. The key is the user's uid
 * and the value is the user's name.
 */
function _station_schedule_program_load_djs($program_nid) {
  // load the dj's users users under the djs item.
  $djs = array();
  $result = db_query('SELECT d.uid, u.name FROM {station_dj} d INNER JOIN {users} u ON d.uid = u.uid WHERE d.program_nid = %d ORDER BY u.name', $program_nid);
  while ($dj = db_fetch_object($result)) {
    $djs[$dj->uid] = $dj->name;
  }
  return $djs;
}

/**
 * Returns an array of themed DJs.
 */
function station_schedule_program_get_themed_djs($program_node) {
  // make djs into links
  $djs = array();
  foreach ((array) $program_node->djs as $uid => $name) {
    if (!empty($name)) {
      $user = user_load(array('uid' => $uid));
      $djs[] = theme('username', $user);
    }
  }
  return $djs;
}

/**
 * Returns a themed array of the times a program is scheduled.
 */
function station_schedule_program_get_themed_times($program_node) {
  $ret = array();
  foreach ((array) $program_node->times as $schedule_nid => $times) {
    foreach ($times as $time) {
      $ret[$schedule_nid][] = theme('station_dayhour_range', $time['start'], $time['finish']);
    }
  }
  return $ret;
}

/**
 * Implementation of hook_xmlrpc().
 */
function station_schedule_xmlrpc() {
  return array(
    array(
      'station.program.get.at',
      'station_schedule_program_get_at',
      array('array', 'int', 'int'),
      t('Fetch info on the program playing at a day/hour of a given timestamp.')
    ),
    array(
      'station.schedule.get.list',
      'station_schedule_get_list',
      array('array'),
      t('Fetch a list of schedules on this site.')
    ),
    array(
      'station.program.get.list',
      'station_schedule_get_program_list',
      array('array'),
      t('Fetch a list of programs on this site.')
    ),
  );
}

/**
 * Function to redirect old /schedule/* links and /station/schedule/*
 * node/$default/*.
 */
function station_schedule_redirect_old($day = '', $hour = '') {
  $nid = variable_get('station_schedule_default', 0);
  $path = "node/$nid/view";
  if ($day) {
    $path .= "/$day";
    if ($hour) {
      $path .= "/$hour";
    }
  }
  drupal_goto($path);
}

/**
 * Return a list of schedules on this site.
 *
 * @return
 *   Array of schedules.
 */
function station_schedule_get_list() {
  global $base_url;

  $schedules = array();
  $result = db_query("SELECT n.nid, n.title, ss.increment, ss.streams, ss.unscheduled_message FROM {node} n INNER JOIN {station_schedule} ss ON n.nid = ss.nid WHERE n.type = 'station_schedule'");
  while ($schedule = db_fetch_array($result)) {
    $schedule['base_url'] = $base_url;

    if (isset($schedule['streams']) && $streams = unserialize($schedule['streams'])) {
      $schedule['streams'] = array();
      foreach ($streams as $key => $stream) {
        // Add in the M3U URL.
        $stream['m3u_url'] = url('node/'. $schedule['nid'] .'/'. $key .'.m3u', NULL, NULL, TRUE);
        $schedule['streams'][$key] = $stream;
      }
    }
    else {
      $schedule['streams'] = array();
    }

    $schedules[$schedule['nid']] = $schedule;
  }

  return $schedules;
}

/**
 * Return a list of schedules on this site.
 *
 * @return
 *   Array of schedules.
 */
function station_schedule_get_program_list() {
  static $schedules;

  if (!isset($schedules)) {
    $schedules = array();
    $result = db_query("SELECT n.nid, n.title FROM {node} n WHERE n.type = 'station_program'");
    while ($o = db_fetch_array($result)) {
      $schedules[$o['nid']] = $o;
    }
  }

  return $schedules;
}
/**
 * Get the program playing at a certain time. If no time is provide, use the
 * current time.
 *
 * @param $gmt_timestamp
 *   a timestamp used to determine the day of the week an hour.
 * @param $schedule_nid
 *   Schedule node id.
 * @return
 *   program node object if one is scheduled, an empty object if nothing is
 *   scheduled.
 */
function station_schedule_program_get_at($gmt_timestamp, $schedule_nid) {
  // Load the schedule item based on the time.
  $ts = station_local_ts($gmt_timestamp);
  $minute = station_minute_from_day_hour(date('w', $ts), date('G', $ts));

  $schedule_item = db_fetch_object(db_query('SELECT * FROM {station_schedule_item} s WHERE s.schedule_nid = %d AND s.start <= %d AND s.finish > %d', $schedule_nid, $minute, $minute));

  // If there's an associated program, load it
  if (isset($schedule_item->program_nid)) {
    if ($node = node_load($schedule_item->program_nid)) {
      // set this so that if the show is scheduled for multiple times the caller
      // can easily figure out which one.
      $node->may_archive = $schedule_item->may_archive;
      // put this in so they can use a pretty url
      $node->node_url = url('node/'. $node->nid, NULL, NULL, TRUE);
      return $node;
    }
  }
  return new stdClass();
}

/**
 * Load the schedule item by its id.
 * @param $iid schedule item id
 * @return schedule item object
 */
function station_schedule_load_item($iid) {
  $result = db_query('SELECT * FROM {station_schedule_item} i WHERE i.iid = %d', $iid);
  if ($o = db_fetch_object($result)) {
    return $o;
  }
}

function station_schedule_item_list($node) {
  drupal_add_css(drupal_get_path('module', 'station_schedule') .'/station_schedule.css');
  drupal_set_title(check_plain($node->title));

  $header = array();
  $row = array();
  foreach ($node->schedule as $day => $items) {
    $header[$day] = station_day_name($day);
    $row[$day] = '';

    // The last finish pointer starts at the beginning of the day.
    $last_finish = $day * MINUTES_IN_DAY;
    $day_finish = ($day + 1) * MINUTES_IN_DAY;
    foreach ($items as $item) {
      // Display blocks for unscheduled time periods
      if ($last_finish != $item->start) {
        $row[$day] .= theme('station_schedule_admin_nonitem', $node, $last_finish, $item->start);
      }
      $last_finish = $item->finish;

      // Display the schedule item
      $item->program = node_load($item->program_nid);
      $row[$day] .= theme('station_schedule_admin_item', $node, $item);
    }
    // Display a block for any remaining time during the day.
    if ($last_finish < $day_finish) {
      $row[$day] .= theme('station_schedule_admin_nonitem', $node, $last_finish, $day_finish);
    }
  }

  // Render the table
  return theme('table', $header, array($row), array('id' => 'station-sch', 'class' => 'station-sch-admin'));
}

function theme_station_schedule_admin_nonitem($node, $start, $finish) {
  $class = 'station-sch-box station-sch-unscheduled';
  $height = ($finish - $start);
  $link = url("node/{$node->nid}/schedule/add/0/{$start}/{$finish}");

  $output = "<div class='{$class}'><a id='schedule-{$start}' href='{$link}' style='height: {$height}px;'>";
  $output .= '<span class="station-sch-time">'. theme('station_hour_range', $start, $finish) .'</span>';
  $output .= '<span class="station-sch-title">'. t('<em>Unscheduled</em>') .'</span>';
  $output .= "</a></div>\n";

  return $output;
}

function theme_station_schedule_admin_item($node, $item) {
  $class = 'station-sch-box station-sch-scheduled';
  $height = ($item->finish - $item->start);
  $link = url("node/{$node->nid}/schedule/edit/{$item->iid}");

  $output = "<div class='{$class}'><a id='schedule-{$item->start}' href='{$link}' style='height: {$height}px;'>";
  $output .= '<span class="station-sch-time">'. theme('station_hour_range', $item->start, $item->finish) .'</span>';
  $output .= '<span class="station-sch-title">'. check_plain($item->program->title) .'</span>';
  $output .= "</a></div>\n";

  return $output;
}

/**
 * @param $op
 *   String 'add' or 'edit'.
 * @param $node
 *   A station_schedule node.
 * @param $id
 *   Integer when adding it's a program id. when editing, it's a schedule item
 *   id.
 */
function station_schedule_item_edit_form($op, $node, $id = NULL, $start = 0, $finish = 60) {
  $post_op = $_POST['op'];
  if ($post_op == t('Cancel')) {
    drupal_goto("node/{$node->nid}/schedule", NULL, "schedule-{$start}");
  }
  if ($post_op == t('Remove')) {
    drupal_goto("node/{$node->nid}/schedule/remove/$id");
  }

  if ($op == 'add') {
    if ($id && $program = node_load($id)) {
      $program_title = $program->title;
    }
    $schedule_item = new stdClass;
    $schedule_item->schedule_nid = $node->nid;
    $schedule_item->iid = $id;
    $schedule_item->start = (int) $start;
    $schedule_item->finish = (int) $finish;
    $schedule_item->may_archive = TRUE;

    drupal_set_title(t('Add item to %title', array('%title' => $node->title)));
  }
  else if ($op == 'edit') {
    if ($id && $schedule_item = station_schedule_load_item($id)) {
      $program = node_load($schedule_item->program_nid);
      $program_title = $program->title;
      $form['iid'] = array(
        '#type' => 'value',
        '#value' => $schedule_item->iid,
      );
    }
    else {
      drupal_goto("node/{$node->nid}/schedule");
    }
    drupal_set_title(t('Edit %title item', array('%title' => $node->title)));
  }

  $day_options = station_day_name();
  $minute_options = array();
  // Make sure the increment will advance the counter.
  $increment = ($node->settings['increment'] < 1) ? 1 : $node->settings['increment'];
  for ($minute = 0; $minute <= 24 * 60; $minute += $increment) {
    $time = station_time_from_minute($minute);
    $minute_options[$minute] = $time['time'] . $time['a'];
  }


  $form['schedule_nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['start_day'] = array(
    '#type' => 'select',
    '#title' => t('Starts'),
    '#default_value' => station_day_from_minute($schedule_item->start),
    '#options' => $day_options,
  );
  $form['start_minutes'] = array(
    '#type' => 'select',
    '#default_value' => $schedule_item->start % MINUTES_IN_DAY,
    '#options' => $minute_options,
  );
  $form['finish_day'] = array(
    '#type' => 'select',
    '#title' => t('Ends'),
    '#default_value' => station_day_from_minute($schedule_item->finish),
    '#options' => $day_options,
    '#description' => $description,
  );
  $form['finish_minutes'] = array(
    '#type' => 'select',
    '#default_value' => $schedule_item->finish % MINUTES_IN_DAY,
    '#options' => $minute_options,
  );
  // Make sure a range that ends on midnigh of one day gets pushed back
  // to the previous day.
  if ($form['finish_minutes']['#default_value'] == 0) {
    $form['finish_day']['#default_value']--;
    $form['finish_minutes']['#default_value'] = MINUTES_IN_DAY;
  }
  $form['program_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Program'),
    '#description' => t("Enter the name of the program."),
    '#default_value' => $program_title,
    '#maxlength' => 128,
    '#autocomplete_path' => 'station/autocomplete/program',
  );
  $form['may_archive'] = array(
    '#type' => 'checkbox',
    '#title' => t('Can be saved in Station Archive'),
    '#default_value' => $schedule_item->may_archive,
    '#description' => t('Checking this indicates that the Station Archive module can save audio recordings of the program at this timeslot to the archive.'),
  );

  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  if ($schedule_item->iid) {
    $form['buttons']['remove'] = array(
      '#type' => 'button',
      '#value' => t('Remove'),
    );
  }
  $form['buttons']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
  );

  return $form;
}

function station_schedule_item_edit_form_validate($form_id, $form_values) {
  $start = ($form_values['start_day'] * MINUTES_IN_DAY) + $form_values['start_minutes'];
  $finish = ($form_values['finish_day'] * MINUTES_IN_DAY) + $form_values['finish_minutes'];

  if ($start >= $finish) {
    form_set_error('finish', t("The program must start before it finishes."));
  }

  $result = db_query('SELECT count(*) AS count, min(s.start) AS start, max(s.finish) AS finish FROM {station_schedule_item} s WHERE s.schedule_nid = %d AND s.iid <> %d AND s.finish > %d AND s.start < %d', $form_values['schedule_nid'], $form_values['iid'], $start, $finish);
  if ($overlap = db_fetch_object($result)) {
    if ($overlap->count == 1) {
      form_set_error('', t("The program overlaps another scheduled item at %time.", array('%time' => theme('station_dayhour_range', $overlap->start, $overlap->finish))));
    }
    else if ($overlap->count > 1) {
      form_set_error('', t("The program overlaps %number scheduled items from %time.", array('%time' => theme('station_dayhour_range', $overlap->start, $overlap->finish), '%number' => $overlap->count)));
    }
  }

  // check for a valid program title
  if (!$prog = node_load(array('title' => $form_values['program_title'], 'type' => 'station_program'))) {
    form_set_error('program_title', t('You need to specify a valid program name.'));
  }
}

function station_schedule_item_edit_form_submit($form_id, $form_values) {
  $schedule_nid = $form_values['schedule_nid'];

  $start = ($form_values['start_day'] * MINUTES_IN_DAY) + $form_values['start_minutes'];
  $finish = ($form_values['finish_day'] * MINUTES_IN_DAY) + $form_values['finish_minutes'];

  $program = node_load(array('type' => 'station_program', 'title' => $form_values['program_title']));

  if ($form_values['iid']) {
    $old_sch = station_schedule_load_item($form_values['iid']);
    db_query("UPDATE {station_schedule_item} SET program_nid = %d, start = %d, finish = %d, may_archive = %d WHERE iid = %d",
      $program->nid, $start, $finish, $form_values['may_archive'], $form_values['iid']);
    if ($old_sch->program_nid != $program->nid) {
      _station_send_notice('schedule', 'remove', array('schedule_nid' => $schedule_nid, 'program_nid' => $old_sch->program_nid, 'iid' => $form_values['iid']));
      _station_send_notice('schedule', 'add', array('schedule_nid' => $schedule_nid, 'program_nid' => $program->nid, 'iid' => $form_values['iid']));
    }
    elseif ($old_sch->start != $start || $old_sch->finish != $finish) {
      _station_send_notice('schedule', 'change', array('schedule_nid' => $schedule_nid, 'program_nid' => $program->nid, 'iid' => $form_values['iid']));
    }
  }
  else {
    $iid = db_next_id('{station_schedule_item}_iid');
    db_query("INSERT INTO {station_schedule_item} (schedule_nid, iid, program_nid, start, finish, may_archive) VALUES (%d, %d, %d, %d, %d, %d)",
     $schedule_nid, $iid, $program->nid, $start, $finish, $form_values['may_archive']);
    _station_send_notice('schedule', 'add', array('schedule_nid' => $schedule_nid, 'program_nid' => $program->nid, 'iid' => $iid));
  }
  drupal_goto("node/{$schedule_nid}/schedule", NULL, "schedule-{$start}");
}

/**
 * Page to confirm the removal of a schedule item.
 */
function station_schedule_item_remove_form($node, $iid = '') {
  $schedule_item = station_schedule_load_item($iid);
  if (!$schedule_item) {
    return "node/{$node->nid}/schedule";
  }
  $program = node_load($schedule_item->program_nid);

  $form['schedule_nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['program_nid'] = array('#type' => 'value', '#value' => $schedule_item->program_nid);
  $form['iid'] = array('#type' => 'value', '#value' => $schedule_item->iid);
  return confirm_form(
    $form,
    t('Are you sure you want to unschedule %title from %schedule at %time?', array('%title' => $program->title, '%schedule' => $node->title, '%time' => theme('station_dayhour_range', $schedule_item->start, $schedule_item->finish))),
    $_GET['destination'] ? $_GET['destination'] : "node/{$node->nid}/schedule/edit/{$schedule_item->iid}",
    t('This action cannot be undone, but you can always re-add the program to the schedule.'),
    t('Remove'),
    t('Cancel')
  );
}

/**
 * Delete a schedule item.
 */
function station_schedule_item_remove_form_submit($formid, $form) {
  if ($form['confirm']) {
    db_query("DELETE FROM {station_schedule_item} WHERE iid = %d", $form['iid']);
    _station_send_notice('schedule', 'remove', array('schedule_nid' => $form['schedule_nid'], 'program_nid' => $form['program_nid'], 'iid' => $form['iid']));
    return "node/{$form['schedule_nid']}/schedule";
  }
}

/**
 * Implementation of hook_view().
 *
 * Display a weekly view for the schedule.
 */
function station_schedule_view($node, $teaser = FALSE, $page = FALSE) {
  drupal_add_css(drupal_get_path('module', 'station_schedule') .'/station_schedule.css');

  if ($page) {
    $breadcrumb = array();
    $breadcrumb[] = array('path' => 'station', 'title' => t('Station'));
    $breadcrumb[] = array('path' => 'station/schedule', 'title' => t('Schedules'));
    $breadcrumb[] = array('path' => 'node/'. $node->nid);
    menu_set_location($breadcrumb);
  }

  $node = node_prepare($node, $teaser);
  if ($teaser) {
    $node->content['streams'] = array(
      '#title' => t('Webstreams'),
      '#value' => theme('station_streams', $node->settings['streams']),
      '#weight' => -5,
    );
  }
  else {
    $node->content['weekly_schedule'] = array(
      '#value' => station_schedule_week_page($node),
      '#weight' => 1,
    );
  }
  return $node;
}

/**
 * Print a weekly schedule page.
 */
function station_schedule_week_page($node) {
  $header[0] = array('data' => t('Time'));
  $row = array();

  // First column is hours.
  $row[0]['id'] = 'station-sch-hours';
  for ($hour = 0; $hour < 24; $hour++) {
    $row[0]['data'] .= theme('station_schedule_hour', $hour);
  }

  // Then a column for each day of the week.
  foreach ((array) $node->schedule as $day => $items) {
    $header[$day + 1]['data'] = station_day_name($day);
    $row[$day + 1]['data'] = '';

    // The last finish pointer starts at the beginning of the day.
    $last_finish = $day * MINUTES_IN_DAY;
    $day_finish = ($day + 1) * MINUTES_IN_DAY;
    foreach ($items as $item) {
      // Display blocks for unscheduled time periods
      if ($last_finish != $item->start) {
        $row[$day + 1]['data'] .= theme('station_schedule_spacer', $last_finish, $item->start);
      }
      $last_finish = $item->finish;

      // Display the schedule item.
      $program = node_load($item->program_nid);
      $row[$day + 1]['data'] .= theme('station_schedule_item', $item->start, $item->finish, $program);
    }
    // Display a block for any remaining time during the day.
    if ($last_finish < $day_finish) {
      $row[$day + 1]['data'] .= theme('station_schedule_spacer', $last_finish, $day_finish);
    }
  }

  // Add a class to indicate what day it is.
  $today = station_today();
  $header[$today + 1]['class'] = 'station-sch-now-day';
  $row[$today + 1]['class'] = 'station-sch-now-day';
 
  return theme('table', $header, array($row), array('id' => 'station-sch'));
}

function theme_station_schedule_hour($hour) {
  $class = 'station-sch-box station-sch-hour';
  $height = 60;
  $output = "<div class='{$class}' style='height:{$height}px;'>";
  $output .= theme('station_hour', $hour * 60);
  $output .= "</div>\n";
  return $output;
}

function theme_station_schedule_spacer($start, $finish) {
  $class = 'station-sch-box station-sch-unscheduled';
  $height = ($finish - $start);
  $output = "<div class='{$class}' style='height:{$height}px;'>";
  $output .= "<span class='station-sch-time'>". theme('station_hour_range', $start, $finish) ."</span>";
  $output .= "</div>\n";
  return $output;
}

function theme_station_schedule_item($start, $finish, $program) {
  $class = 'station-sch-box station-sch-scheduled';
  $height = ($finish - $start);
  $link = url('node/'. $program->nid);

  $output = "<div class='{$class}'><a href='{$link}' style='height: {$height}px;'>";
  $output .= '<span class="station-sch-time">'. theme('station_hour_range', $start, $finish) .'</span>';
  $output .= '<span class="station-sch-title">'. check_plain($program->title) .'</span>';
  if ($program->djs) {
    $output .= '<span class="station-sch-djs">'. check_plain(implode(', ', $program->djs)) .'</span>';
  }
  $output .= "</a></div>\n";
  return $output;
}

/**
 * Print a day's schedule page.
 */
function station_schedule_day_page($node, $day) {
  drupal_set_title(check_plain($node->title));
  
  if ($view = views_get_view('station_schedule_day')) {
    // Set $view->url to current page so views with exposed filters submit
    // back to the same page
    $view->url = $_GET['q'];
    $view_args = array($node->nid, $day);
    return views_build_view('embed', $view, $view_args, FALSE, NULL);
  }
  return drupal_not_found();
}

/**
 * Send the client an M3U file of the streams.
 *
 * @param $stream An array with a 'urls' item containing an array of webstream
 *   URLs.
 */
function station_schedule_stream_m3u($stream) {
  drupal_set_header('Content-Type: audio/mpegurl');
  $output = '';
  foreach ($stream['urls'] as $url) {
    $output .= $url ."\n";
  }
  print $output;
  exit();
}
